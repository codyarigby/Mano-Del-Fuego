   // TI File $Revision:  $
// Checkin $Date:  $
//###########################################################################
//
// FILE:	Senior_Main.c
//
// TITLE:	DSP2833x McBSP to AIC23 Audio Codec Interface via DMA
//
// ASSUMPTIONS:
//
//    This program requires the DSP2833x header files.
//    As supplied, this project is configured for "boot to SARAM"
//    operation.  The 2833x Boot Mode table is shown below.
//
//       $Boot_Table:
//
//         GPIO87   GPIO86     GPIO85   GPIO84
//          XA15     XA14       XA13     XA12
//           PU       PU         PU       PU
//        ==========================================
//            1        1          1        1    Jump to Flash
//            1        1          1        0    SCI-A boot
//            1        1          0        1    SPI-A boot
//            1        1          0        0    I2C-A boot
//            1        0          1        1    eCAN-A boot
//            1        0          1        0    McBSP-A boot
//            1        0          0        1    Jump to XINTF x16
//            1        0          0        0    Jump to XINTF x32
//            0        1          1        1    Jump to OTP
//            0        1          1        0    Parallel GPIO I/O boot
//            0        1          0        1    Parallel XINTF boot
//            0        1          0        0    Jump to SARAM	    <- "boot to SARAM"
//            0        0          1        1    Branch to check boot mode
//            0        0          1        0    Boot to flash, bypass ADC cal
//            0        0          0        1    Boot to SARAM, bypass ADC cal
//            0        0          0        0    Boot to SCI-A, bypass ADC cal
//                                              Boot_Table_End$
//
// DESCRIPTION:
//
// This program will transmit and receive audio data between the DSP2833x McBSP and
// the TLV320AIC23B Stereo Audio Codec configured for DSP or I2S mode.  The following connections
// are requred -
//
// EXTERNAL CONNECTIONS:
//
// Audio Connections
//
//  AIC23               McBSP-A
//----------------------------------------------
//  DIN         ---      MDXA
//  LRCIN       ---      MFSXA
//  BCLK        ---      MCLKXA/MCLKRA (short)
//  DOUT        ---      MDRA
//  LRCOUT      ---      MFSRA
//  Feed Line In from CD/DVD/MP3 headphone jack or audio out
//  Feed HPOUT or Line Out to headphones or speakers respectively
//
// Control Signals
//
//  AIC23               McBSP-B
//----------------------------------
//  SDIN        ---     MDXB
//  SCLK        ---     MCLKXB
//  CSn         ---     MFSXB
//
//
// -----------------------------------------------------------------------------------------
//
//
// * Prior to building and loading code, first select microphone and digital audio interface
// (DSP mode or I2S mode) options using #define MIC and I2S_SEL directives.
//
// Data is transferred as follows:
//
// 1. RRDY signal triggers DMA interrupt as soon as McBSP-A receiver is enabled.
//    - This first interrupt is serviced and ignored because no data has been
//      received yet.
// 2. 32-bits of L-channel data is received in DRR2->DRR1, which is moved by
//    DMA to buffer (ping or pong - starts with ping_buffer[1]).
//    (Remember 32-bit reads read larger address first, then
//    smaller address second - i.e. if buffer is at 0xD000, a 32-bit read of
//    ping_buffer[1] would read MSB in 0xD001, then LSB in 0xD000).
// 3. Then 32-bits of R-channel data is received in DRR2->DRR1, which is moved
//    by DMA to ping(or pong)_buffer[513] (Again, MSB in ping/pong_buffer[513],
//    LSB in ping/pong_buffer[512])
// 4. DMA wraps around - receives L-channel data again, and places it in next 32-bit
//    buffer address. Likewise R-channel is received and data is written to next
//    buffer address (same as Step 3)
// 5. After 512 sets of 32-bit L and R-channel data have been received (1024 sets of
//    16-bit data), DMA channel 1 interrupts indicating buffer is filled.
// 6. Process data in buffer. Then kick off DMA channel 2 here to transmit data
//    from the same buffer from which data was received.
// 7. Change DMA destination address to pong_buff_offset if ping_buff_offset was
//    previous destination address and ping_buff_offset if pong_buff_offset was
//    previous destination address. As soon as interrupt is acknowledged, DMA
//    channel 1 will start receiving from the other buffer while DMA channel 2 is
//    transmitting the first buffer.
// 8. On DMA Channel 2, the transmit is opposite of receive (i.e. source = ping/
//    pong buffer offset destination = McBSP DXR2/DXR1 registers).
//    L/R-channel data moves from buffer to DXR2/DXR1 registers to be tx'ed to
//    AIC23. Then when complete, switch to other ping/pong buffer.
// 9. Steps 2-8 are repeated continuously via interrupts.
//
// Watch Variables:
//        ping_buffer (buffer of 1024 Uint32 values - audio data)
//        pong_buffer (buffer of 1024 Uint32 values - audio data)
//
//
//###########################################################################
// Original Author: Cody Rigby
//###########################################################################

#include "stdlib.h"
#include "math.h"
#include "DSP28x_Project.h"     // Device Headerfile and Examples Include File
//#include "AIC23.h"
#include "DSP2833x_Device.h"     // DSP2833x Headerfile Include File
#include "MDF_init.h"
#include "UI.h"
#include <string.h>



// *** AIC23_DSP_SPI_control.c External Function Prototypes *** //
extern void init_mcbsp_spi();
extern void mcbsp_xmit (int a);
extern void aic23_init(int mic, int i2s_mode);

void mano_del_fuego(void);
void init_structs(void);

// *** Interrupt Definitions *** //
interrupt void local_D_INTCH1_ISR(void); 	// Channel 1 Rx ISR
interrupt void local_D_INTCH2_ISR(void); 	// Channel 2 Tx ISR
interrupt void local_SCIRXINTB_ISR(void);   // Scib Rx ISR aleady defined in pie.h
interrupt void local_timer_ISR(void);		// timer isr
interrupt void local_XINT1_ISR(void);
interrupt void local_XINT3_ISR(void);
interrupt void local_XINT4_ISR(void);
interrupt void local_XINT5_ISR(void);
interrupt void local_XINT6_ISR(void);


//===============================================================
// SELECT AUDIO INPUT AND DIGITAL AUDIO INTERFACE OPTIONS HERE:
//===============================================================
#define MIC 		0      	// 0 = line input, 1 = microphone input
#define I2S_SEL 	0  		// 0 = normal DSP McBSP dig. interface, 1 = I2S interface

//effect defines
#define WAH 		1
#define FLANGER 	3
#define VOLSWELL 	2
#define BYPASS 		0
#define PITCHUP		4
#define PITCHDOWN   5



// *******************************************************************************************************
// 							hanning windows
// *******************************************************************************************************
//static float hanning[256] = {0, 0.00030118, 0.0012045, 0.0027095, 0.0048153, 0.0075205, 0.010823, 0.014722, 0.019215, 0.024298, 0.029969, 0.036224, 0.04306, 0.050472, 0.058456, 0.067007, 0.07612, 0.08579, 0.096011, 0.10678, 0.11808, 0.12991, 0.14227, 0.15515, 0.16853, 0.18242, 0.19679, 0.21165, 0.22699, 0.24279, 0.25905, 0.27575, 0.29289, 0.31046, 0.32844, 0.34683, 0.36561, 0.38477, 0.4043, 0.42419, 0.44443, 0.465, 0.4859, 0.5071, 0.5286, 0.55039, 0.57244, 0.59476, 0.61732, 0.6401, 0.66311, 0.68632, 0.70972, 0.73329, 0.75702, 0.7809, 0.80491, 0.82904, 0.85327, 0.87759, 0.90198, 0.92644, 0.95093, 0.97546, 1, 1.0245, 1.0491, 1.0736, 1.098, 1.1224, 1.1467, 1.171, 1.1951, 1.2191, 1.243, 1.2667, 1.2903, 1.3137, 1.3369, 1.3599, 1.3827, 1.4052, 1.4276, 1.4496, 1.4714, 1.4929, 1.5141, 1.535, 1.5556, 1.5758, 1.5957, 1.6152, 1.6344, 1.6532, 1.6716, 1.6895, 1.7071, 1.7242, 1.741, 1.7572, 1.773, 1.7883, 1.8032, 1.8176, 1.8315, 1.8449, 1.8577, 1.8701, 1.8819, 1.8932, 1.904, 1.9142, 1.9239, 1.933, 1.9415, 1.9495, 1.9569, 1.9638, 1.97, 1.9757, 1.9808, 1.9853, 1.9892, 1.9925, 1.9952, 1.9973, 1.9988, 1.9997, 2, 1.9997, 1.9988, 1.9973, 1.9952, 1.9925, 1.9892, 1.9853, 1.9808, 1.9757, 1.97, 1.9638, 1.9569, 1.9495, 1.9415, 1.933, 1.9239, 1.9142, 1.904, 1.8932, 1.8819, 1.8701, 1.8577, 1.8449, 1.8315, 1.8176, 1.8032, 1.7883, 1.773, 1.7572, 1.741, 1.7242, 1.7071, 1.6895, 1.6716, 1.6532, 1.6344, 1.6152, 1.5957, 1.5758, 1.5556, 1.535, 1.5141, 1.4929, 1.4714, 1.4496, 1.4276, 1.4052, 1.3827, 1.3599, 1.3369, 1.3137, 1.2903, 1.2667, 1.243, 1.2191, 1.1951, 1.171, 1.1467, 1.1224, 1.098, 1.0736, 1.0491, 1.0245, 1, 0.97546, 0.95093, 0.92644, 0.90198, 0.87759, 0.85327, 0.82904, 0.80491, 0.7809, 0.75702, 0.73329, 0.70972, 0.68632, 0.66311, 0.6401, 0.61732, 0.59476, 0.57244, 0.55039, 0.5286, 0.5071, 0.4859, 0.465, 0.44443, 0.42419, 0.4043, 0.38477, 0.36561, 0.34683, 0.32844, 0.31046, 0.29289, 0.27575, 0.25905, 0.24279, 0.22699, 0.21165, 0.19679, 0.18242, 0.16853, 0.15515, 0.14227, 0.12991, 0.11808, 0.10678, 0.096011, 0.08579, 0.07612, 0.067007, 0.058456, 0.050472, 0.04306, 0.036224, 0.029969, 0.024298, 0.019215, 0.014722, 0.010823, 0.0075205, 0.0048153, 0.0027095, 0.0012045, 0.00030118};
//static float hanning[1024] = {1, 0.99998, 0.99992, 0.99983, 0.9997, 0.99953, 0.99932, 0.99908, 0.9988, 0.99848, 0.99812, 0.99772, 0.99729, 0.99682, 0.99631, 0.99577, 0.99518, 0.99456, 0.99391, 0.99321, 0.99248, 0.99171, 0.9909, 0.99006, 0.98918, 0.98826, 0.9873, 0.98631, 0.98528, 0.98421, 0.98311, 0.98196, 0.98078, 0.97957, 0.97832, 0.97703, 0.9757, 0.97434, 0.97294, 0.9715, 0.97003, 0.96852, 0.96698, 0.96539, 0.96378, 0.96212, 0.96043, 0.9587, 0.95694, 0.95514, 0.9533, 0.95143, 0.94953, 0.94758, 0.94561, 0.94359, 0.94154, 0.93946, 0.93734, 0.93518, 0.93299, 0.93077, 0.9285, 0.92621, 0.92388, 0.92151, 0.91911, 0.91668, 0.91421, 0.9117, 0.90917, 0.90659, 0.90399, 0.90135, 0.89867, 0.89596, 0.89322, 0.89045, 0.88764, 0.88479, 0.88192, 0.87901, 0.87607, 0.87309, 0.87008, 0.86704, 0.86397, 0.86086, 0.85773, 0.85455, 0.85135, 0.84812, 0.84485, 0.84155, 0.83822, 0.83486, 0.83147, 0.82804, 0.82459, 0.8211, 0.81758, 0.81403, 0.81045, 0.80684, 0.8032, 0.79953, 0.79583, 0.7921, 0.78834, 0.78455, 0.78073, 0.77688, 0.773, 0.7691, 0.76516, 0.7612, 0.7572, 0.75318, 0.74913, 0.74505, 0.74094, 0.73681, 0.73265, 0.72846, 0.72424, 0.72, 0.71572, 0.71143, 0.7071, 0.70275, 0.69837, 0.69396, 0.68953, 0.68508, 0.68059, 0.67609, 0.67155, 0.66699, 0.66241, 0.6578, 0.65316, 0.64851, 0.64382, 0.63912, 0.63438, 0.62963, 0.62485, 0.62005, 0.61522, 0.61037, 0.6055, 0.60061, 0.59569, 0.59075, 0.58579, 0.5808, 0.5758, 0.57077, 0.56572, 0.56065, 0.55556, 0.55045, 0.54531, 0.54016, 0.53499, 0.52979, 0.52458, 0.51935, 0.51409, 0.50882, 0.50353, 0.49822, 0.49289, 0.48754, 0.48217, 0.47679, 0.47138, 0.46596, 0.46053, 0.45507, 0.4496, 0.44411, 0.4386, 0.43308, 0.42754, 0.42199, 0.41642, 0.41083, 0.40523, 0.39961, 0.39398, 0.38833, 0.38267, 0.37699, 0.3713, 0.3656, 0.35988, 0.35415, 0.3484, 0.34265, 0.33688, 0.33109, 0.3253, 0.31949, 0.31367, 0.30783, 0.30199, 0.29614, 0.29027, 0.28439, 0.2785, 0.27261, 0.2667, 0.26078, 0.25485, 0.24891, 0.24296, 0.23701, 0.23104, 0.22507, 0.21908, 0.21309, 0.20709, 0.20109, 0.19507, 0.18905, 0.18302, 0.17699, 0.17094, 0.1649, 0.15884, 0.15278, 0.14671, 0.14064, 0.13456, 0.12848, 0.12239, 0.1163, 0.1102, 0.1041, 0.097999, 0.091891, 0.085779, 0.079664, 0.073546, 0.067425, 0.061302, 0.055176, 0.049049, 0.042919, 0.036788, 0.030656, 0.024522, 0.018387, 0.012252, 0.0061163, -1.9673e-05, -0.0061556, -0.012291, -0.018427, -0.024561, -0.030695, -0.036827, -0.042958, -0.049088, -0.055216, -0.061341, -0.067464, -0.073585, -0.079703, -0.085818, -0.09193, -0.098038, -0.10414, -0.11024, -0.11634, -0.12243, -0.12852, -0.1346, -0.14068, -0.14675, -0.15282, -0.15888, -0.16493, -0.17098, -0.17703, -0.18306, -0.18909, -0.19511, -0.20113, -0.20713, -0.21313, -0.21912, -0.22511, -0.23108, -0.23705, -0.243, -0.24895, -0.25489, -0.26082, -0.26673, -0.27264, -0.27854, -0.28443, -0.29031, -0.29617, -0.30203, -0.30787, -0.3137, -0.31952, -0.32533, -0.33113, -0.33691, -0.34268, -0.34844, -0.35419, -0.35992, -0.36564, -0.37134, -0.37703, -0.38271, -0.38837, -0.39401, -0.39965, -0.40526, -0.41087, -0.41645, -0.42202, -0.42758, -0.43312, -0.43864, -0.44414, -0.44963, -0.45511, -0.46056, -0.466, -0.47142, -0.47682, -0.48221, -0.48757, -0.49292, -0.49825, -0.50356, -0.50885, -0.51413, -0.51938, -0.52461, -0.52983, -0.53502, -0.54019, -0.54535, -0.55048, -0.55559, -0.56068, -0.56575, -0.5708, -0.57583, -0.58084, -0.58582, -0.59078, -0.59572, -0.60064, -0.60553, -0.6104, -0.61525, -0.62008, -0.62488, -0.62966, -0.63442, -0.63915, -0.64385, -0.64854, -0.65319, -0.65783, -0.66244, -0.66702, -0.67158, -0.67611, -0.68062, -0.6851, -0.68956, -0.69399, -0.6984, -0.70278, -0.70713, -0.71145, -0.71575, -0.72002, -0.72427, -0.72848, -0.73267, -0.73684, -0.74097, -0.74508, -0.74916, -0.75321, -0.75723, -0.76122, -0.76519, -0.76912, -0.77303, -0.77691, -0.78076, -0.78458, -0.78837, -0.79213, -0.79586, -0.79956, -0.80323, -0.80687, -0.81048, -0.81405, -0.8176, -0.82112, -0.82461, -0.82806, -0.83149, -0.83488, -0.83824, -0.84157, -0.84487, -0.84814, -0.85137, -0.85457, -0.85775, -0.86088, -0.86399, -0.86706, -0.8701, -0.87311, -0.87609, -0.87903, -0.88194, -0.88481, -0.88765, -0.89046, -0.89324, -0.89598, -0.89869, -0.90136, -0.904, -0.90661, -0.90918, -0.91172, -0.91422, -0.91669, -0.91913, -0.92153, -0.92389, -0.92622, -0.92852, -0.93078, -0.93301, -0.9352, -0.93735, -0.93947, -0.94156, -0.94361, -0.94562, -0.9476, -0.94954, -0.95145, -0.95332, -0.95515, -0.95695, -0.95871, -0.96044, -0.96213, -0.96379, -0.9654, -0.96699, -0.96853, -0.97004, -0.97151, -0.97295, -0.97435, -0.97571, -0.97704, -0.97832, -0.97958, -0.98079, -0.98197, -0.98311, -0.98422, -0.98528, -0.98631, -0.98731, -0.98826, -0.98918, -0.99006, -0.99091, -0.99171, -0.99248, -0.99322, -0.99391, -0.99457, -0.99519, -0.99577, -0.99632, -0.99682, -0.99729, -0.99773, -0.99812, -0.99848, -0.9988, -0.99908, -0.99932, -0.99953, -0.9997, -0.99983, -0.99993, -0.99998, -1, -0.99998, -0.99992, -0.99983, -0.9997, -0.99953, -0.99932, -0.99908, -0.99879, -0.99847, -0.99812, -0.99772, -0.99729, -0.99682, -0.99631, -0.99576, -0.99518, -0.99456, -0.9939, -0.99321, -0.99247, -0.9917, -0.9909, -0.99005, -0.98917, -0.98825, -0.98729, -0.9863, -0.98527, -0.9842, -0.9831, -0.98196, -0.98078, -0.97956, -0.97831, -0.97702, -0.97569, -0.97433, -0.97293, -0.97149, -0.97002, -0.96851, -0.96697, -0.96538, -0.96376, -0.96211, -0.96042, -0.95869, -0.95693, -0.95513, -0.95329, -0.95142, -0.94951, -0.94757, -0.94559, -0.94358, -0.94153, -0.93944, -0.93732, -0.93517, -0.93298, -0.93075, -0.92849, -0.92619, -0.92386, -0.9215, -0.9191, -0.91666, -0.91419, -0.91169, -0.90915, -0.90658, -0.90397, -0.90133, -0.89865, -0.89595, -0.8932, -0.89043, -0.88762, -0.88478, -0.8819, -0.87899, -0.87605, -0.87307, -0.87006, -0.86702, -0.86395, -0.86084, -0.8577, -0.85453, -0.85133, -0.8481, -0.84483, -0.84153, -0.8382, -0.83484, -0.83144, -0.82802, -0.82456, -0.82108, -0.81756, -0.81401, -0.81043, -0.80682, -0.80318, -0.79951, -0.79581, -0.79208, -0.78832, -0.78453, -0.78071, -0.77686, -0.77298, -0.76907, -0.76514, -0.76117, -0.75718, -0.75316, -0.7491, -0.74503, -0.74092, -0.73678, -0.73262, -0.72843, -0.72421, -0.71997, -0.7157, -0.7114, -0.70707, -0.70272, -0.69834, -0.69394, -0.6895, -0.68505, -0.68056, -0.67606, -0.67152, -0.66696, -0.66238, -0.65777, -0.65313, -0.64848, -0.64379, -0.63909, -0.63435, -0.6296, -0.62482, -0.62002, -0.61519, -0.61034, -0.60547, -0.60058, -0.59566, -0.59072, -0.58576, -0.58077, -0.57577, -0.57074, -0.56569, -0.56062, -0.55553, -0.55041, -0.54528, -0.54013, -0.53495, -0.52976, -0.52455, -0.51931, -0.51406, -0.50879, -0.50349, -0.49818, -0.49285, -0.4875, -0.48214, -0.47675, -0.47135, -0.46593, -0.46049, -0.45504, -0.44956, -0.44407, -0.43857, -0.43305, -0.42751, -0.42195, -0.41638, -0.41079, -0.40519, -0.39957, -0.39394, -0.3883, -0.38263, -0.37696, -0.37127, -0.36556, -0.35984, -0.35411, -0.34837, -0.34261, -0.33684, -0.33105, -0.32526, -0.31945, -0.31363, -0.3078, -0.30195, -0.2961, -0.29023, -0.28435, -0.27847, -0.27257, -0.26666, -0.26074, -0.25481, -0.24887, -0.24293, -0.23697, -0.231, -0.22503, -0.21905, -0.21306, -0.20706, -0.20105, -0.19503, -0.18901, -0.18298, -0.17695, -0.17091, -0.16486, -0.1588, -0.15274, -0.14667, -0.1406, -0.13452, -0.12844, -0.12235, -0.11626, -0.11016, -0.10406, -0.09796, -0.091851, -0.08574, -0.079625, -0.073507, -0.067386, -0.061263, -0.055137, -0.049009, -0.04288, -0.036749, -0.030616, -0.024483, -0.018348, -0.012213, -0.0060769, 5.902e-05, 0.006195, 0.012331, 0.018466, 0.024601, 0.030734, 0.036867, 0.042998, 0.049127, 0.055255, 0.06138, 0.067504, 0.073624, 0.079742, 0.085857, 0.091969, 0.098077, 0.10418, 0.11028, 0.11638, 0.12247, 0.12856, 0.13464, 0.14072, 0.14679, 0.15286, 0.15892, 0.16497, 0.17102, 0.17706, 0.1831, 0.18913, 0.19515, 0.20116, 0.20717, 0.21317, 0.21916, 0.22514, 0.23112, 0.23708, 0.24304, 0.24899, 0.25493, 0.26085, 0.26677, 0.27268, 0.27858, 0.28447, 0.29034, 0.29621, 0.30207, 0.30791, 0.31374, 0.31956, 0.32537, 0.33117, 0.33695, 0.34272, 0.34848, 0.35422, 0.35995, 0.36567, 0.37138, 0.37707, 0.38274, 0.3884, 0.39405, 0.39968, 0.4053, 0.4109, 0.41649, 0.42206, 0.42761, 0.43315, 0.43867, 0.44418, 0.44967, 0.45514, 0.4606, 0.46603, 0.47145, 0.47686, 0.48224, 0.48761, 0.49296, 0.49828, 0.5036, 0.50889, 0.51416, 0.51941, 0.52465, 0.52986, 0.53505, 0.54023, 0.54538, 0.55051, 0.55563, 0.56072, 0.56579, 0.57084, 0.57586, 0.58087, 0.58585, 0.59081, 0.59575, 0.60067, 0.60556, 0.61044, 0.61528, 0.62011, 0.62491, 0.62969, 0.63445, 0.63918, 0.64388, 0.64857, 0.65322, 0.65786, 0.66247, 0.66705, 0.67161, 0.67614, 0.68065, 0.68513, 0.68959, 0.69402, 0.69843, 0.7028, 0.70716, 0.71148, 0.71578, 0.72005, 0.72429, 0.72851, 0.7327, 0.73686, 0.741, 0.7451, 0.74918, 0.75323, 0.75725, 0.76125, 0.76521, 0.76915, 0.77305, 0.77693, 0.78078, 0.7846, 0.78839, 0.79215, 0.79588, 0.79958, 0.80325, 0.80689, 0.8105, 0.81408, 0.81763, 0.82114, 0.82463, 0.82808, 0.83151, 0.8349, 0.83826, 0.84159, 0.84489, 0.84816, 0.85139, 0.8546, 0.85777, 0.8609, 0.86401, 0.86708, 0.87012, 0.87313, 0.8761, 0.87905, 0.88196, 0.88483, 0.88767, 0.89048, 0.89326, 0.896, 0.89871, 0.90138, 0.90402, 0.90663, 0.9092, 0.91174, 0.91424, 0.91671, 0.91914, 0.92154, 0.92391, 0.92624, 0.92853, 0.93079, 0.93302, 0.93521, 0.93736, 0.93948, 0.94157, 0.94362, 0.94563, 0.94761, 0.94955, 0.95146, 0.95333, 0.95516, 0.95696, 0.95872, 0.96045, 0.96214, 0.9638, 0.96541, 0.967, 0.96854, 0.97005, 0.97152, 0.97296, 0.97436, 0.97572, 0.97704, 0.97833, 0.97959, 0.9808, 0.98198, 0.98312, 0.98422, 0.98529, 0.98632, 0.98731, 0.98827, 0.98919, 0.99007, 0.99091, 0.99172, 0.99249, 0.99322, 0.99392, 0.99457, 0.99519, 0.99577, 0.99632, 0.99683, 0.9973, 0.99773, 0.99812, 0.99848, 0.9988, 0.99908, 0.99933, 0.99953, 0.9997, 0.99983, 0.99993, 0.99998};
//static float window_front[112] = {0, 0.017937, 0.035711, 0.053324, 0.070773, 0.088061, 0.10519, 0.12215, 0.13895, 0.15559, 0.17206, 0.18838, 0.20453, 0.22052, 0.23634, 0.25201, 0.26751, 0.28285, 0.29803, 0.31304, 0.3279, 0.34259, 0.35711, 0.37148, 0.38568, 0.39972, 0.4136, 0.42732, 0.44087, 0.45427, 0.46749, 0.48056, 0.49347, 0.50621, 0.51879, 0.53121, 0.54346, 0.55556, 0.56749, 0.57925, 0.59086, 0.60231, 0.61359, 0.62471, 0.63566, 0.64646, 0.65709, 0.66756, 0.67787, 0.68801, 0.698, 0.70782, 0.71747, 0.72697, 0.7363, 0.74548, 0.75448, 0.76333, 0.77202, 0.78054, 0.7889, 0.79709, 0.80513, 0.813, 0.82071, 0.82826, 0.83565, 0.84287, 0.84993, 0.85683, 0.86357, 0.87014, 0.87655, 0.8828, 0.88889, 0.89481, 0.90058, 0.90618, 0.91161, 0.91689, 0.922, 0.92695, 0.93174, 0.93637, 0.94083, 0.94513, 0.94927, 0.95325, 0.95707, 0.96072, 0.96421, 0.96754, 0.9707, 0.9737, 0.97654, 0.97922, 0.98174, 0.98409, 0.98628, 0.98831, 0.99018, 0.99188, 0.99343, 0.99481, 0.99602, 0.99708, 0.99797, 0.9987, 0.99927, 0.99968, 0.99992, 1};
//static float window_back[112] = {1, 0.99992, 0.99968, 0.99927, 0.9987, 0.99797, 0.99708, 0.99602, 0.99481, 0.99343, 0.99188, 0.99018, 0.98831, 0.98628, 0.98409, 0.98174, 0.97922, 0.97654, 0.9737, 0.9707, 0.96754, 0.96421, 0.96072, 0.95707, 0.95325, 0.94927, 0.94513, 0.94083, 0.93637, 0.93174, 0.92695, 0.922, 0.91689, 0.91161, 0.90618, 0.90058, 0.89481, 0.88889, 0.8828, 0.87655, 0.87014, 0.86357, 0.85683, 0.84993, 0.84287, 0.83565, 0.82826, 0.82071, 0.813, 0.80513, 0.79709, 0.7889, 0.78054, 0.77202, 0.76333, 0.75448, 0.74548, 0.7363, 0.72697, 0.71747, 0.70782, 0.698, 0.68801, 0.67787, 0.66756, 0.65709, 0.64646, 0.63566, 0.62471, 0.61359, 0.60231, 0.59086, 0.57925, 0.56749, 0.55556, 0.54346, 0.53121, 0.51879, 0.50621, 0.49347, 0.48056, 0.46749, 0.45427, 0.44087, 0.42732, 0.4136, 0.39972, 0.38568, 0.37148, 0.35711, 0.34259, 0.3279, 0.31304, 0.29803, 0.28285, 0.26751, 0.25201, 0.23634, 0.22052, 0.20453, 0.18838, 0.17206, 0.15559, 0.13895, 0.12215, 0.10519, 0.088061, 0.070773, 0.053324, 0.035711, 0.017937, 0};
/*
static float hanning[1024] = { 0.00000000, 0.00000340, 0.00001358, 0.00003056, 0.00005433, 0.00008491, 0.00012228, 0.00016647, 0.00021747,
		0.00027531, 0.00033997, 0.00041148, 0.00048985, 0.00057509, 0.00066721, 0.00076623, 0.00087217, 0.00098503,
		0.00110485, 0.00123164, 0.00136541, 0.00150620, 0.00165402, 0.00180889, 0.00197085, 0.00213991, 0.00231611,
		0.00249946, 0.00269001, 0.00288778, 0.00309279, 0.00330509, 0.00352470, 0.00375165, 0.00398599, 0.00422775,
		0.00447697, 0.00473367, 0.00499791, 0.00526972, 0.00554913, 0.00583620, 0.00613097, 0.00643347, 0.00674375,
		0.00706186, 0.00738784, 0.00772174, 0.00806360, 0.00841349, 0.00877143, 0.00913749, 0.00951171, 0.00989415,
		0.01028486, 0.01068389, 0.01109130, 0.01150714, 0.01193146, 0.01236433, 0.01280580, 0.01325592, 0.01371476,
		0.01418237, 0.01465881, 0.01514415, 0.01563845, 0.01614176, 0.01665415, 0.01717568, 0.01770641, 0.01824641,
		0.01879575, 0.01935448, 0.01992267, 0.02050040, 0.02108771, 0.02168469, 0.02229140, 0.02290791, 0.02353428,
		0.02417058, 0.02481689, 0.02547326, 0.02613978, 0.02681651, 0.02750352, 0.02820089, 0.02890867, 0.02962695,
		0.03035579, 0.03109527, 0.03184546, 0.03260643, 0.03337826, 0.03416101, 0.03495475, 0.03575957, 0.03657553,
		0.03740270, 0.03824116, 0.03909099, 0.03995224, 0.04082501, 0.04170936, 0.04260535, 0.04351308, 0.04443260,
		0.04536400, 0.04630733, 0.04726269, 0.04823013, 0.04920974, 0.05020158, 0.05120572, 0.05222224, 0.05325120,
		0.05429269, 0.05534677, 0.05641350, 0.05749297, 0.05858524, 0.05969037, 0.06080845, 0.06193953, 0.06308369,
		0.06424100, 0.06541152, 0.06659531, 0.06779245, 0.06900301, 0.07022704, 0.07146461, 0.07271578, 0.07398063,
		0.07525921, 0.07655159, 0.07785783, 0.07917798, 0.08051212, 0.08186029, 0.08322257, 0.08459900, 0.08598964,
		0.08739456, 0.08881381, 0.09024744, 0.09169551, 0.09315807, 0.09463518, 0.09612688, 0.09763324, 0.09915429,
		0.10069008, 0.10224067, 0.10380611, 0.10538643, 0.10698169, 0.10859193, 0.11021718, 0.11185750, 0.11351293,
		0.11518350, 0.11686925, 0.11857023, 0.12028646, 0.12201799, 0.12376484, 0.12552706, 0.12730466, 0.12909769,
		0.13090617, 0.13273014, 0.13456960, 0.13642461, 0.13829516, 0.14018130, 0.14208304, 0.14400040, 0.14593340,
		0.14788206, 0.14984640, 0.15182642, 0.15382214, 0.15583358, 0.15786074, 0.15990363, 0.16196227, 0.16403665,
		0.16612678, 0.16823267, 0.17035431, 0.17249170, 0.17464485, 0.17681375, 0.17899839, 0.18119878, 0.18341489,
		0.18564672, 0.18789427, 0.19015751, 0.19243643, 0.19473102, 0.19704126, 0.19936713, 0.20170861, 0.20406567,
		0.20643829, 0.20882644, 0.21123010, 0.21364924, 0.21608383, 0.21853382, 0.22099919, 0.22347991, 0.22597592,
		0.22848720, 0.23101370, 0.23355537, 0.23611217, 0.23868406, 0.24127098, 0.24387289, 0.24648972, 0.24912143,
		0.25176796, 0.25442925, 0.25710525, 0.25979588, 0.26250109, 0.26522081, 0.26795497, 0.27070351, 0.27346635,
		0.27624341, 0.27903464, 0.28183994, 0.28465924, 0.28749247, 0.29033953, 0.29320034, 0.29607482, 0.29896288,
		0.30186444, 0.30477939, 0.30770764, 0.31064911, 0.31360369, 0.31657129, 0.31955180, 0.32254512, 0.32555115,
		0.32856978, 0.33160090, 0.33464441, 0.33770018, 0.34076812, 0.34384809, 0.34694000, 0.35004370, 0.35315910,
		0.35628605, 0.35942444, 0.36257415, 0.36573504, 0.36890698, 0.37208985, 0.37528350, 0.37848781, 0.38170264,
		0.38492784, 0.38816328, 0.39140882, 0.39466431, 0.39792961, 0.40120456, 0.40448903, 0.40778286, 0.41108589,
		0.41439798, 0.41771897, 0.42104869, 0.42438700, 0.42773373, 0.43108872, 0.43445181, 0.43782282, 0.44120160,
		0.44458797, 0.44798177, 0.45138282, 0.45479095, 0.45820599, 0.46162775, 0.46505607, 0.46849076, 0.47193164,
		0.47537854, 0.47883126, 0.48228962, 0.48575343, 0.48922252, 0.49269668, 0.49617574, 0.49965949, 0.50314774,
		0.50664031, 0.51013699, 0.51363758, 0.51714190, 0.52064973, 0.52416089, 0.52767516, 0.53119235, 0.53471225,
		0.53823466, 0.54175936, 0.54528616, 0.54881484, 0.55234519, 0.55587701, 0.55941008, 0.56294419, 0.56647912,
		0.57001466, 0.57355060, 0.57708671, 0.58062279, 0.58415861, 0.58769395, 0.59122860, 0.59476232, 0.59829491,
		0.60182614, 0.60535578, 0.60888362, 0.61240941, 0.61593296, 0.61945401, 0.62297236, 0.62648776, 0.63000000,
		0.63350884, 0.63701406, 0.64051543, 0.64401271, 0.64750568, 0.65099410, 0.65447775, 0.65795638, 0.66142978,
		0.66489770, 0.66835992, 0.67181620, 0.67526630, 0.67871000, 0.68214705, 0.68557723, 0.68900030, 0.69241603,
		0.69582418, 0.69922451, 0.70261679, 0.70600079, 0.70937627, 0.71274299, 0.71610073, 0.71944923, 0.72278828,
		0.72611764, 0.72943706, 0.73274632, 0.73604518, 0.73933341, 0.74261076, 0.74587702, 0.74913194, 0.75237529,
		0.75560684, 0.75882635, 0.76203360, 0.76522835, 0.76841036, 0.77157942, 0.77473528, 0.77787771, 0.78100650,
		0.78412140, 0.78722219, 0.79030864, 0.79338053, 0.79643762, 0.79947969, 0.80250652, 0.80551787, 0.80851354,
		0.81149328, 0.81445689, 0.81740414, 0.82033480, 0.82324867, 0.82614551, 0.82902511, 0.83188726, 0.83473174,
		0.83755833, 0.84036681, 0.84315699, 0.84592863, 0.84868154, 0.85141550, 0.85413031, 0.85682575, 0.85950162,
		0.86215771, 0.86479382, 0.86740976, 0.87000530, 0.87258027, 0.87513445, 0.87766765, 0.88017967, 0.88267032,
		0.88513941, 0.88758674, 0.89001212, 0.89241537, 0.89479629, 0.89715471, 0.89949043, 0.90180327, 0.90409306,
		0.90635961, 0.90860274, 0.91082228, 0.91301805, 0.91518988, 0.91733761, 0.91946105, 0.92156004, 0.92363442,
		0.92568402, 0.92770867, 0.92970823, 0.93168252, 0.93363140, 0.93555471, 0.93745228, 0.93932398, 0.94116966,
		0.94298916, 0.94478234, 0.94654906, 0.94828917, 0.95000254, 0.95168903, 0.95334851, 0.95498083, 0.95658588,
		0.95816351, 0.95971361, 0.96123605, 0.96273070, 0.96419745, 0.96563618, 0.96704677, 0.96842911, 0.96978308,
		0.97110858, 0.97240549, 0.97367373, 0.97491317, 0.97612372, 0.97730529, 0.97845777, 0.97958108, 0.98067512,
		0.98173980, 0.98277504, 0.98378076, 0.98475686, 0.98570328, 0.98661992, 0.98750673, 0.98836363, 0.98919055,
		0.98998741, 0.99075416, 0.99149074, 0.99219707, 0.99287312, 0.99351881, 0.99413410, 0.99471893, 0.99527327,
		0.99579706, 0.99629026, 0.99675283, 0.99718473, 0.99758593, 0.99795640, 0.99829610, 0.99860501, 0.99888310,
		0.99913034, 0.99934673, 0.99953223, 0.99968685, 0.99981055, 0.99990334, 0.99996520, 0.99999613, 0.99999613,
		0.99996520, 0.99990334, 0.99981055, 0.99968685, 0.99953223, 0.99934673, 0.99913034, 0.99888310, 0.99860501,
		0.99829610, 0.99795640, 0.99758593, 0.99718473, 0.99675283, 0.99629026, 0.99579706, 0.99527327, 0.99471893,
		0.99413410, 0.99351881, 0.99287312, 0.99219707, 0.99149074, 0.99075416, 0.98998741, 0.98919055, 0.98836363,
		0.98750673, 0.98661992, 0.98570328, 0.98475686, 0.98378076, 0.98277504, 0.98173980, 0.98067512, 0.97958108,
		0.97845777, 0.97730529, 0.97612372, 0.97491317, 0.97367373, 0.97240549, 0.97110858, 0.96978308, 0.96842911,
		0.96704677, 0.96563618, 0.96419745, 0.96273070, 0.96123605, 0.95971361, 0.95816351, 0.95658588, 0.95498083,
		0.95334851, 0.95168903, 0.95000254, 0.94828917, 0.94654906, 0.94478234, 0.94298916, 0.94116966, 0.93932398,
		0.93745228, 0.93555471, 0.93363140, 0.93168252, 0.92970823, 0.92770867, 0.92568402, 0.92363442, 0.92156004,
		0.91946105, 0.91733761, 0.91518988, 0.91301805, 0.91082228, 0.90860274, 0.90635961, 0.90409306, 0.90180327,
		0.89949043, 0.89715471, 0.89479629, 0.89241537, 0.89001212, 0.88758674, 0.88513941, 0.88267032, 0.88017967,
		0.87766765, 0.87513445, 0.87258027, 0.87000530, 0.86740976, 0.86479382, 0.86215771, 0.85950162, 0.85682575,
		0.85413031, 0.85141550, 0.84868154, 0.84592863, 0.84315699, 0.84036681, 0.83755833, 0.83473174, 0.83188726,
		0.82902511, 0.82614551, 0.82324867, 0.82033480, 0.81740414, 0.81445689, 0.81149328, 0.80851354, 0.80551787,
		0.80250652, 0.79947969, 0.79643762, 0.79338053, 0.79030864, 0.78722219, 0.78412140, 0.78100650, 0.77787771,
		0.77473528, 0.77157942, 0.76841036, 0.76522835, 0.76203360, 0.75882635, 0.75560684, 0.75237529, 0.74913194,
		0.74587702, 0.74261076, 0.73933341, 0.73604518, 0.73274632, 0.72943706, 0.72611764, 0.72278828, 0.71944923,
		0.71610073, 0.71274299, 0.70937627, 0.70600079, 0.70261679, 0.69922451, 0.69582418, 0.69241603, 0.68900030,
		0.68557723, 0.68214705, 0.67871000, 0.67526630, 0.67181620, 0.66835992, 0.66489770, 0.66142978, 0.65795638,
		0.65447775, 0.65099410, 0.64750568, 0.64401271, 0.64051543, 0.63701406, 0.63350884, 0.63000000, 0.62648776,
		0.62297236, 0.61945401, 0.61593296, 0.61240941, 0.60888362, 0.60535578, 0.60182614, 0.59829491, 0.59476232,
		0.59122860, 0.58769395, 0.58415861, 0.58062279, 0.57708671, 0.57355060, 0.57001466, 0.56647912, 0.56294419,
		0.55941008, 0.55587701, 0.55234519, 0.54881484, 0.54528616, 0.54175936, 0.53823466, 0.53471225, 0.53119235,
		0.52767516, 0.52416089, 0.52064973, 0.51714190, 0.51363758, 0.51013699, 0.50664031, 0.50314774, 0.49965949,
		0.49617574, 0.49269668, 0.48922252, 0.48575343, 0.48228962, 0.47883126, 0.47537854, 0.47193164, 0.46849076,
		0.46505607, 0.46162775, 0.45820599, 0.45479095, 0.45138282, 0.44798177, 0.44458797, 0.44120160, 0.43782282,
		0.43445181, 0.43108872, 0.42773373, 0.42438700, 0.42104869, 0.41771897, 0.41439798, 0.41108589, 0.40778286,
		0.40448903, 0.40120456, 0.39792961, 0.39466431, 0.39140882, 0.38816328, 0.38492784, 0.38170264, 0.37848781,
		0.37528350, 0.37208985, 0.36890698, 0.36573504, 0.36257415, 0.35942444, 0.35628605, 0.35315910, 0.35004370,
		0.34694000, 0.34384809, 0.34076812, 0.33770018, 0.33464441, 0.33160090, 0.32856978, 0.32555115, 0.32254512,
		0.31955180, 0.31657129, 0.31360369, 0.31064911, 0.30770764, 0.30477939, 0.30186444, 0.29896288, 0.29607482,
		0.29320034, 0.29033953, 0.28749247, 0.28465924, 0.28183994, 0.27903464, 0.27624341, 0.27346635, 0.27070351,
		0.26795497, 0.26522081, 0.26250109, 0.25979588, 0.25710525, 0.25442925, 0.25176796, 0.24912143, 0.24648972,
		0.24387289, 0.24127098, 0.23868406, 0.23611217, 0.23355537, 0.23101370, 0.22848720, 0.22597592, 0.22347991,
		0.22099919, 0.21853382, 0.21608383, 0.21364924, 0.21123010, 0.20882644, 0.20643829, 0.20406567, 0.20170861,
		0.19936713, 0.19704126, 0.19473102, 0.19243643, 0.19015751, 0.18789427, 0.18564672, 0.18341489, 0.18119878,
		0.17899839, 0.17681375, 0.17464485, 0.17249170, 0.17035431, 0.16823267, 0.16612678, 0.16403665, 0.16196227,
		0.15990363, 0.15786074, 0.15583358, 0.15382214, 0.15182642, 0.14984640, 0.14788206, 0.14593340, 0.14400040,
		0.14208304, 0.14018130, 0.13829516, 0.13642461, 0.13456960, 0.13273014, 0.13090617, 0.12909769, 0.12730466,
		0.12552706, 0.12376484, 0.12201799, 0.12028646, 0.11857023, 0.11686925, 0.11518350, 0.11351293, 0.11185750,
		0.11021718, 0.10859193, 0.10698169, 0.10538643, 0.10380611, 0.10224067, 0.10069008, 0.09915429, 0.09763324,
		0.09612688, 0.09463518, 0.09315807, 0.09169551, 0.09024744, 0.08881381, 0.08739456, 0.08598964, 0.08459900,
		0.08322257, 0.08186029, 0.08051212, 0.07917798, 0.07785783, 0.07655159, 0.07525921, 0.07398063, 0.07271578,
		0.07146461, 0.07022704, 0.06900301, 0.06779245, 0.06659531, 0.06541152, 0.06424100, 0.06308369, 0.06193953,
		0.06080845, 0.05969037, 0.05858524, 0.05749297, 0.05641350, 0.05534677, 0.05429269, 0.05325120, 0.05222224,
		0.05120572, 0.05020158, 0.04920974, 0.04823013, 0.04726269, 0.04630733, 0.04536400, 0.04443260, 0.04351308,
		0.04260535, 0.04170936, 0.04082501, 0.03995224, 0.03909099, 0.03824116, 0.03740270, 0.03657553, 0.03575957,
		0.03495475, 0.03416101, 0.03337826, 0.03260643, 0.03184546, 0.03109527, 0.03035579, 0.02962695, 0.02890867,
		0.02820089, 0.02750352, 0.02681651, 0.02613978, 0.02547326, 0.02481689, 0.02417058, 0.02353428, 0.02290791,
		0.02229140, 0.02168469, 0.02108771, 0.02050040, 0.01992267, 0.01935448, 0.01879575, 0.01824641, 0.01770641,
		0.01717568, 0.01665415, 0.01614176, 0.01563845, 0.01514415, 0.01465881, 0.01418237, 0.01371476, 0.01325592,
		0.01280580, 0.01236433, 0.01193146, 0.01150714, 0.01109130, 0.01068389, 0.01028486, 0.00989415, 0.00951171,
		0.00913749, 0.00877143, 0.00841349, 0.00806360, 0.00772174, 0.00738784, 0.00706186, 0.00674375, 0.00643347,
		0.00613097, 0.00583620, 0.00554913, 0.00526972, 0.00499791, 0.00473367, 0.00447697, 0.00422775, 0.00398599,
		0.00375165, 0.00352470, 0.00330509, 0.00309279, 0.00288778, 0.00269001, 0.00249946, 0.00231611, 0.00213991,
		0.00197085, 0.00180889, 0.00165402, 0.00150620, 0.00136541, 0.00123164, 0.00110485, 0.00098503, 0.00087217,
		0.00076623, 0.00066721, 0.00057509, 0.00048985, 0.00041148, 0.00033997, 0.00027531, 0.00021747, 0.00016647,
		0.00012228, 0.00008491, 0.00005433, 0.00003056, 0.00001358, 0.00000340, 0.00000340};
*/





#pragma DATA_SECTION (ping_buffer, "DMARAML5"); // Place ping and pong in DMA RAM L5
#pragma DATA_SECTION (pong_buffer, "DMARAML5");
#pragma DATA_SECTION(ext_Buffer, "extSRAM6");
#pragma DATA_SECTION(pitch_shift, "EFFECTRAM6");
#pragma DATA_SECTION(sample, "EFFECTRAM6");
#pragma DATA_SECTION(zcross_pos, "EFFECTRAM6");
#pragma DATA_SECTION(zcross_neg, "EFFECTRAM6");
#pragma DATA_SECTION(imu_dat, "EFFECTRAM6");
#pragma DATA_SECTION(flang, "EFFECTRAM6");
#pragma DATA_SECTION(dig_delay, "EFFECTRAM6");
#pragma DATA_SECTION(tremolo, "EFFECTRAM6");
#pragma DATA_SECTION(wah_svf, "EFFECTRAM6");
#pragma DATA_SECTION(bass_svf, "EFFECTRAM6");
#pragma DATA_SECTION(treble_svf, "EFFECTRAM6");

/*
interrupt void local_D_INTCH1_ISR(void); 	// Channel 1 Rx ISR
interrupt void local_D_INTCH2_ISR(void); 	// Channel 2 Tx ISR
interrupt void local_SCIRXINTB_ISR(void);   // Scib Rx ISR aleady defined in pie.h
interrupt void local_timer_ISR(void);		// timer isr
interrupt void local_XINT1_ISR(void);
interrupt void local_XINT3_ISR(void);
interrupt void local_XINT4_ISR(void);
interrupt void local_XINT5_ISR(void);
interrupt void local_XINT6_ISR(void);
*/

/*
#pragma CODE_SECTION(local_D_INTCH1_ISR, "ramfuncs");
#pragma CODE_SECTION(local_D_INTCH2_ISR, "ramfuncs");
#pragma CODE_SECTION(local_SCIRXINTB_ISR, "ramfuncs");
#pragma CODE_SECTION(local_timer_ISR, "ramfuncs");
#pragma CODE_SECTION(local_XINT1_ISR, "ramfuncs");
#pragma CODE_SECTION(local_XINT3_ISR, "ramfuncs");
#pragma CODE_SECTION(local_XINT4_ISR, "ramfuncs");
#pragma CODE_SECTION(local_XINT5_ISR, "ramfuncs");
#pragma CODE_SECTION(local_XINT6_ISR, "ramfuncs");
#pragma CODE_SECTION(mano_del_fuego, "ramfuncs");
#pragma CODE_SECTION(init_structs, "ramfuncs");
*/



// *** These are defined by the linker (see F28335.cmd) *** //
/*
extern Uint16 RamfuncsLoadStart;
extern Uint16 RamfuncsLoadEnd;
extern Uint16 RamfuncsRunStart;
extern Uint16 RamfuncsLoadSize;
*/





//extern void Init_gpioUI(void);
//#pragma CODE_SECTION(Init_gpioUI, "DMARAML7");


Uint16 prevcountstart;

int16 ext_Buffer[32767];
Uint16 ext_Buffer_size = 32767; // and these pointers with 0x7FFF
// *******************************************************************************************************
// 							Pitch Shifting variables
// *******************************************************************************************************

struct PITCH_SHIFT{
	Uint16 Direction;
	float PerUpper;
	float PerLower;
	float Per;
	Uint16 count_delay1;
	Uint16 ext_index_delay1;
	int16 ext_delay;
	int16 ext_delay_prev;
	Uint16 PerReset;
} pitch_shift;


// *** shared by both pitch shifter and delay based effects *** //
int16 ext_prev;
Uint16 ext_index;

// *** variables used in zcross calculation *** //
int16 closest_d;
int16 temp_d;
int16 closest_d;
Uint16 temp_index;
Uint16 temp_count_offset;

struct SAMPLE {
	   int16 samp[5];
	   Uint16 index[5];
	   Uint16 count;
} sample;

struct SAMPLE_DELAY {
	   int16 samp[5];
	   Uint16 index[5];
	   Uint16 count;
} sample_delay;


struct ZCROSS_POS {
   int16   cross_samp[5];
   Uint16  cross_index[5];
   Uint16  count_delay;
} zcross_pos;

struct ZCROSS_NEG{
	   int16   cross_samp[5];
	   Uint16  cross_index[5];
	   Uint16  count_delay;
} zcross_neg;

//interpolation tools
int16 ext_prev_inter;
int16 interpol_inc;

// *******************************************************************************************************
// 							Audio sample related variables
// *******************************************************************************************************

// ping pong buffers for right and left channels
Uint16 ping_buffer[2];  							// Note that Uint16 is used, not Uint32
Uint16 pong_buffer[2];								//
Uint16 p_buff_size = 2;
Uint16 * L_channel = &ping_buffer[0];				// This pointer points to the beginning of the L-C data in either of the buffers
Uint16 * R_channel = &ping_buffer[1];				// This pointer points to the beginning of the R-C data in either of the buffers
Uint32 ping_buff_offset = (Uint32) &ping_buffer[0]; // start address of ping buffer
Uint32 pong_buff_offset = (Uint32) &pong_buffer[0]; // start address of pong buffer
int16 * ch1_ptr; 									// ptr that points to ping/pong buffer that just received data

// *******************************************************************************************************
// 							Bluetooth / IMU sample related variables
// *******************************************************************************************************
// Address used to connect bluetooth modules
char			fastDataMode[4] = {'C', 'F', 'R' ,'\n' };
char 			address[15] = {'C', ',', '0', '0', '0', '6', '6', '6' ,'D', 'A', '0', '9', 'B', '7', '\n'};
static Uint16   wah_timer;
Uint16  		buffer_uart[128];					// Buffer to view samples from IMU over time
int 			uart_i = 0;								// uart buffer index
Uint16  		uart_step = 0; 						// if the interrupt receives a 0xA when uart_step is 0 then a transfer has begun!
int  			scib_rx;								// variable that holds the received BT data
int16			scib_gyro;
float			gyro_vol = 1.0;
float accel_mag;

struct IMU {
   int16  XaccelPrev;
   int16  Xaccel;
   int16  XgyroPrev;
   int16  Xgyro;
   float  Xa_velocity;
   float  Xa_velocity_prev;
   float  Xa_pos;
   float  Xg_velocity;
   float  Xg_velocity_prev;
   float  Xg_pos;
   float  Xaccel_real;
   float  Xaccel_real_prev;
} imu_dat;



// *******************************************************************************************************
// 							Delay Effects and Sine Buffer related variables
// *******************************************************************************************************
int16 gyro_pos;
int16 gyro_pos_prev;
int16 delay_const = 96;			// center of delay for the flanger/chorus effect
int16 delay = 512;  			// delay value for effect
Uint16 fb = 0;					// forward backward for delay related effects
Uint16 timer_delay 		= 100;
Uint16 timer_reset 		= 0;
Uint16 zcross_period 	= 0;

struct FLANG {
	Uint16 upper_delay;
	Uint16 lower_delay;
	float  speed[10];
	Uint16 delay;
	Uint16 delay_range[10];
	int16  delay_index;
} flang;

struct DELAY {
	Uint16 upper_delay;
	Uint16 lower_delay;
	Uint16 speed[10];
	Uint16 delay;
	int16  delay_index;
} dig_delay;

struct TREMOLO {
	float amplitude[10];
	float periodHigh;
	float periodLow;
	float period;
	float periodrange[10];
} tremolo;


// *******************************************************************************************************
// 							interrupt flag variables
// *******************************************************************************************************
Uint16 t1_flag = 0;				// timer 1 flag set in timer interrupt
Uint16 r_flag1 = 0; 			// flag set in interrupt to que data process
Uint16 r_flag2 = 0; 			// flag set in interrupt to que data process
Uint16 d_flag;					// flag for uart (I think)
Uint16 first_interrupt = 1;   	// 1 indicates first interrupt
Uint16 activateEffect = 0;
Uint16 activateCounter = 0;
Uint16 deactivateCounter = 0;
Uint16 nextCounter = 0;
Uint16 nextCounter2 = 0;
Uint16 nextHold = 0;

// *******************************************************************************************************
// 							UI Variables
// *******************************************************************************************************



// Dummy Counter Variables
Uint16 Xint_count   	= 0;
Uint16 Button1_count 	= 0;
Uint16 Button2_count 	= 0;
Uint16 Button3_count 	= 0;
Uint16 Button4_count 	= 0;
Uint16 ButtonUp_count	= 0;
Uint16 ButtonDown_count = 0;


Uint16 zcrosstrig;


// *******************************************************************************************************
// 							State Variable Filter Variables
// *******************************************************************************************************
// State Variable Filter Stucture
// damp = 0.05, Q = 2*damp
// F controller by timer 0
struct SVF {
   float Fupper;		    // upper boundary of F
   float Flower;            // lower boundary of F
   float F;	     			// Tuning Coefficient  F1 = 2sin(pi*fc/fs)
   float Q[10];				// Tuning Coefficient  Q1 = 2sigma (10 different Q values to select from)
   float F_range[10];       // 10 different wah ranges
   float HPF;
   float BPF[2];
   float LPF[2];
};
struct SVF wah_svf;
struct SVF bass_svf;
struct SVF treble_svf;



// *** Dummy Variables used for visualization in debugging *** //
//float fIn;
float dummy_buffer[1024];
Uint16 dummy_index = 0;
//float *dptr = &dummy_buffer[0];


// *******************************************************************************************************
// 							Misc
// *******************************************************************************************************
Uint16 toggler				= 0;
Uint16 ii 					= 0;
Uint16 k 					= 0;
Uint16 effectsel			= BYPASS;

//effect UI Control
bool   state_change_flag    = false;
Uint16 p1					= 0;
Uint16 p2					= 0;

void main(void)

{

   //InitSysCtrl();
   //memcpy(&RamfuncsRunStart, &RamfuncsLoadStart, (Uint32)&RamfuncsLoadSize);

   // Call Flash Initialization to setup flash waitstates
   // This function must reside in RAM
   //InitFlash();
   InitSysCtrl();
   //InitFlash();


   EALLOW;

   // Initalize GPIO:
   // For this example, enable the GPIO PINS for McBSP operation.
   InitMcbspGpio();

   init_Xintf();

   // Fill the buffers with dummy data
   for(k=0; k<p_buff_size; k++) { ping_buffer[k] = 0x0000; }
   for(k=0; k<p_buff_size; k++) { pong_buffer[k] = 0x0000; }
   for(k=0; k<ext_Buffer_size; k++) { ext_Buffer[k] = 0xEEEE; }
   ping_buff_offset++;    		// Start at location 1
   pong_buff_offset++;    		// Start at location 1

   // Clear all interrupts and initialize PIE vector table:
   // Disable CPU interrupts
   DINT;

   // Initialize PIE control registers to their default state.
   // The default state is all PIE interrupts disabled and flags
   // are cleared.
   // This function is found in the DSP2833x_PieCtrl.c file.
   InitPieCtrl();

   EALLOW;
   DINT;						// Disable interrupts again (for now)



   // Disable CPU interrupts and clear all CPU interrupt flags:
   IER = 0x0000;
   IFR = 0x0000;

    init_mcbsp_spi();      		// Initialize McBSP-B as SPI Control
    Init_gpioUI();
    DELAY_US(900000L);

    aic23_init(MIC, I2S_SEL);  	// Set up AIC23 w/ McBSP-B
    DELAY_US(90L);
    DELAY_US(900000L);

	init_dma(ping_buff_offset, pong_buff_offset);					// Initialize the DMA before McBSP, so that DMA is ready to transfer the McBSP data
   	init_mcbspa();      		// Initalize McBSP-A for audio data transfers with audio codec
    delay_loop();				// Delay loop
    Init_timer1();				// Initialize timer 1
    EALLOW;

    //DmaRegs.CH1.CONTROL.bit.RUN = 1; // Start rx on Channel 1

    // Assign ISRS
    PieVectTable.SCIRXINTB 	= &local_SCIRXINTB_ISR; // ISR Triggered by RXRDY flag
	PieVectTable.DINTCH1 	= &local_D_INTCH1_ISR;	// Triggered by DMA Channel 1 Transfer
    //PieVectTable.DINTCH2 	= &local_D_INTCH2_ISR;  // Triggered by DMA Channel 2 Transfer
    PieVectTable.XINT13     = &local_timer_ISR;		// Triggered by Timer 1

    PieVectTable.XINT1 		= &local_XINT1_ISR;		// Triggered by GPIO9
    PieVectTable.XINT3 		= &local_XINT3_ISR;		// Triggered by GPIO32 (stomp0 SDAA)
    PieVectTable.XINT4 		= &local_XINT4_ISR;		// Triggered by GPIO33 (stomp1 SCLA)
    PieVectTable.XINT5 		= &local_XINT5_ISR;		// Triggered by GPIO35 (stomp2 XRWn )
    PieVectTable.XINT6 		= &local_XINT6_ISR;		// Triggered by GPIO34 (stomp3 XREADY)

    // Configure PIE interrupts
	PieCtrlRegs.PIECTRL.bit.ENPIE = 1;  // Enable vector fetching from PIE block
	PieCtrlRegs.PIECTRL.all  |= 1;  	// Enable vector fetching from PIE block

	// Enable PIE to drive pulse from different PIE groups into the CPU
	//PieCtrlRegs.PIEACK.all = 0xFFFF;    // Enables PIE to drive a pulse into the CPU
	PieCtrlRegs.PIEACK.bit.ACK12 = 1;      // Enables PIE to drive a pulse into the CPU
	PieCtrlRegs.PIEACK.bit.ACK1  = 1;      // Enables PIE to drive a pulse into the CPU
	PieCtrlRegs.PIEACK.bit.ACK7  = 1;      // Enables PIE to drive a pulse into the CPU
	PieCtrlRegs.PIEACK.bit.ACK9  = 1;      // Enables PIE to drive a pulse into the CPU
	//PieCtrlRegs.PIEACK.bit.ACK3 = 1;    // Enables PIE to drive a pulse into the CPU

	// The interrupt can be asserted in the following interrupt lines
	PieCtrlRegs.PIEIER12.bit.INTx1 = 1;  // Enable PIE Group12 INT1 (XINT3)
	PieCtrlRegs.PIEIER12.bit.INTx2 = 1;  // Enable PIE Group12 INT2 (XINT4)
	PieCtrlRegs.PIEIER12.bit.INTx3 = 1;  // Enable PIE Group12 INT3 (XINT5)
	PieCtrlRegs.PIEIER12.bit.INTx4 = 1;  // Enable PIE Group12 INT4 (XINT6)
	PieCtrlRegs.PIEIER1.bit.INTx4 = 1;  // Enable PIE Group 1 INT4 (XINT1)
	PieCtrlRegs.PIEIER7.bit.INTx1 = 1;	// Enable INTx.1 of INT7 (DMA CH1)
	PieCtrlRegs.PIEIER7.bit.INTx2 = 1;  // Enable INTx.2 of INT7 (DMA CH2)
	PieCtrlRegs.PIEIER9.bit.INTx3 = 1;  // Enable INTx.3 of INT9 (SCIB RXRDY Flag)
	//DmaRegs.CH1.CONTROL.bit.RUN = 1; // Start rx on Channel 1


// *******************************************************************************************************
// 							Initialize the Bluetooth Module
// *******************************************************************************************************
/*
init_uart();
scib_xmit('$');
DELAY_US(10000L);
scib_xmit('$');
DELAY_US(10000L);
scib_xmit('$');
DELAY_US(10000L);
*/


// set to fast data mode
init_uart();
for(ii = 0; ii < 4; ii++)
{
	scib_xmit(fastDataMode[ii]);
	DELAY_US(2000L);
}
/*
// send out the BT module address
for(ii = 0; ii < 15; ii++)
{
	scib_xmit(address[ii]);
	DELAY_US(2000L);
}
*/
// the BT  module will now connect to the MCM's bluetooth module
DELAY_US(10000L);

//Initialize_Board();





// *** Enable all interrupt channels *** //
// *** UI is disabled for this application
//IER |= M_INT12;								// Enable Xint for Stomp Buttons
//IER |= M_INT1;								// Enable Xint for UI Buttons
IER |= M_INT13;								// Enable Interrupt for timer 1
IER |= PIEACK_GROUP7;					    // Enable  INT7
IER |= PIEACK_GROUP9;						// Enable  INT9
EINT;      					        		// Global enable of interrupts

rx_flag = false;
//Initialize_Board();

//CpuTimer1.RegsAddr->TCR.bit.TSS = 0; // start the timer
DmaRegs.CH1.CONTROL.bit.RUN = 1; // Start rx on Channel 1
EDIS;
delay = 0;
k = 0;
// **************** NEED TO WRITE A ROUTINE THAT INITIALIZES THE EFFECTS STRUCTURES ************************************//
init_structs();

imu_dat.XaccelPrev 	= 0;
imu_dat.Xaccel		= 0;
imu_dat.XgyroPrev	= 0;
imu_dat.Xgyro		= 0;
imu_dat.Xa_velocity = 0.0;
imu_dat.Xa_velocity_prev = 0.0;
imu_dat.Xa_pos = 0.0;
imu_dat.Xg_velocity = 0.0;
imu_dat.Xg_velocity_prev = 0.0;
imu_dat.Xg_pos = 0.0;
imu_dat.Xaccel_real = 0.0;
imu_dat.Xaccel_real_prev = 0.0;

effectsel = PITCHUP;
  	while(1) {
	// Code loops here all the time
  	mano_del_fuego();
}
}

//===========================================================================
// End of main()
//===========================================================================


interrupt void local_timer_ISR()
{


  //if(t1_flag == 1){
  //  t1_flag=1;
  //}
  //if(t1_flag==0){
  //  t1_flag=1;
  //}
  t1_flag = 1;						// set the flag for timer processing
  CpuTimer1Regs.TCR.bit.TIF = 1;	// acknowledge interrupt
  CpuTimer1Regs.TCR.bit.TSS = 0;	//
}






interrupt void local_SCIRXINTB_ISR(void) // SCI-B
{

	EALLOW;
	if(ScibRegs.SCIRXBUF.all == 0x0A && uart_step == 0)
	{
		uart_step++;
		//uart_i++;
	}
	else if(uart_step == 1)
	{
		scib_rx = ((ScibRegs.SCIRXBUF.all << 8) & 0xFF00);
		if((scib_rx & 0xFF00) == 0x0A00)
		{
			uart_step = 0;
		}
		else
		{
			uart_step++;
		}
	}
	else if(uart_step == 2)
	{
		scib_rx |= ScibRegs.SCIRXBUF.all;

		// if we were just getting accel data, uncomment the next two lines
		//uart_step = 0;
		//d_flag = 1;

		uart_step++;
	}
	else if(uart_step == 3)
	{
		scib_gyro = ((ScibRegs.SCIRXBUF.all << 8) & 0xFF00);
		if((scib_gyro & 0xFF00) == 0x0A00)
		{
			uart_step = 0;
		}
		else
		{
			uart_step++;
		}
	}
	else if(uart_step == 4)
	{
		scib_gyro |= ScibRegs.SCIRXBUF.all;
		uart_step = 0;
		d_flag = 1;

	}
	else
	{
		uart_step = 0;
	}

	//Uint16 activateEffect = 0;
	//Uint16 activateCounter = 0;
	//Uint16 deactivateCounter = 0;
	rx_flag = true;
	PieCtrlRegs.PIEACK.all |= PIEACK_GROUP9;       // Issue PIE ack
}




// INT7.1 -
interrupt void local_D_INTCH1_ISR(void)		// DMA Ch1 - McBSP-A Rx
{
    EALLOW;

    //if(first_interrupt==1) // No processing needs to be done (B/c interrupt occurs
	//{                      // at beginning of DMA transfers to ping buffer - no data received yet)
	//    first_interrupt=0; // Turn flag off and exit interrupt
	//} else
	//{
	// Do whatever processing is needed on the buffered data  outside of the ISR
  	// Once that is done, switch to the other buffer
	// DmaRegs.CH2.CONTROL.bit.RUN = 1; // Start tx on CH2 after CH1 has finished ping buffer
	// dont start dma channel 2
	//}

    // this is to check if the DMA makes a transfer during the audio processing
    if(r_flag1)
    {
    	r_flag1 = 1;
    }

    //	When DMA first starts working on ping buffer, set the shadow registers
    //	to start at pong buffer next time and vice versa
    if(DmaRegs.CH1.DST_ADDR_SHADOW == ping_buff_offset)
	{
		DmaRegs.CH1.DST_ADDR_SHADOW = pong_buff_offset;
  		DmaRegs.CH1.DST_BEG_ADDR_SHADOW = pong_buff_offset;
  		ch1_ptr = ping_buff_offset; // set channel pointer to the previous ping/pong buffer because that is where the data was just recorded
	}
	else
	{
		DmaRegs.CH1.DST_ADDR_SHADOW = ping_buff_offset;
  		DmaRegs.CH1.DST_BEG_ADDR_SHADOW = ping_buff_offset;
  		ch1_ptr = pong_buff_offset; // set channel pointer to the previous ping/pong buffer because that is where the data was just recorded
	}
    // To receive more interrupts from this PIE group, acknowledge this interrupt
    r_flag1 = 1;
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;
    EDIS;
}



interrupt void local_XINT1_ISR(void)
{
	/*
	bool Button1 = false;
	bool Button2 = false;
	bool Button3 = false;
	bool Button4 = false;
	bool ButtonUp = false;
	bool ButtonDown = false;
	*/

	/*
	Uint16 Xint_count   	= 0;
	Uint16 Button1_count 	= 0;
	Uint16 Button2_count 	= 0;
	Uint16 Button3_count 	= 0;
	Uint16 Button4_count 	= 0;
	Uint16 ButtonUp_count	= 0;
	Uint16 ButtonDown_count = 0;
	*/

	Xint_count++;
	if(GpioDataRegs.GPADAT.bit.GPIO0 == 0)
	{
		// "Button Up" has been pressed
		ButtonUp = true;
		ButtonUp_count++;
	}
	if(GpioDataRegs.GPADAT.bit.GPIO1 == 0)
	{
		// "Button Down" has been pressed
		ButtonDown = true;
		ButtonDown_count++;
	}
	if(GpioDataRegs.GPADAT.bit.GPIO2 == 0)
	{
		// "Button 1" has been pressed
		Button1 = true;
		Button1_count++;

	}
	if(GpioDataRegs.GPADAT.bit.GPIO3 == 0)
	{
		// "Button 2" has been pressed
		Button2 = true;
		Button2_count++;
	}
	if(GpioDataRegs.GPADAT.bit.GPIO4 == 0)
	{
		// "Button 3" has been pressed
		Button3 = true;
		Button3_count++;
	}
	if(GpioDataRegs.GPADAT.bit.GPIO6 == 0)
	{
		// "Button 4" has been pressed
		Button4 = true;
		Button4_count++;
	}

	State_Change();
	// *** ENTER NICKS FUNCTION *** //
	// Acknowledge this interrupt to get more from group 1
	PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}

//extern bool Switch1;
//extern bool Switch2;
//extern bool Switch3;
//extern bool Switch4;


interrupt void local_XINT3_ISR(void)
{

	// Stomp0 has been pressed
	Switch1 = true;
	// send 0x0 to the decoder
	State_Change();
	// Acknowledge this interrupt to get more from group 12
	PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;
}
interrupt void local_XINT4_ISR(void)
{

	// Stomp1 has been pressed
	Switch2 = true;
	// send 0x1 to the decoder
	State_Change();
	// Acknowledge this interrupt to get more from group 12
	PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;
}
interrupt void local_XINT5_ISR(void)
{

	// Stomp2 has been pressed
	Switch3 = true;
	// send 0x2 to the decoder
	State_Change();
	// Acknowledge this interrupt to get more from group 12
	PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;
}
interrupt void local_XINT6_ISR(void)
{

	// Stomp3 has been pressed
	Switch4 = true;
	// send 0x3 to the decoder
	State_Change();
	// Acknowledge this interrupt to get more from group 12
	PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;
}


//initialize all structures
void init_structs(void)
{


/*
	struct FLANG {
		Uint16 upper_delay;
		Uint16 lower_delay;
		float speed[10];
		Uint16 delay;
		Uint16 delay_range[10];
		int16  delay_index;
	} flang;
*/


	flang.speed[0] = 500.0;    		// 100us default
	flang.speed[1] = 750.0;    		// 100us default
	flang.speed[2] = 1000.0;    		// 100us default
	flang.speed[3] = 1200.0;    		// 100us default
	flang.speed[4] = 1300.0;    		// 100us default
	flang.speed[5] = 1500.0;    		// 100us default
	flang.speed[6] = 1800.0;    		// 100us default
	flang.speed[7] = 2000.0;    		// 100us default
	flang.speed[8] = 3000.0;    		// 100us default
	flang.speed[9] = 4000.0;    		// 100us default

	flang.delay_range[0] = 32;
	flang.delay_range[1] = 64;
	flang.delay_range[2] = 128;
	flang.delay_range[4] = 156;
	flang.delay_range[5] = 256;
	flang.delay_range[6] = 356;
	flang.delay_range[7] = 412;
	flang.delay_range[8] = 512;
	flang.delay_range[8] = 712;
	flang.delay 		 = 1024;

/*
	struct DELAY {
		Uint16 upper_delay;
		Uint16 lower_delay;
		Uint16 speed;
		Uint16 delay;
		int16  delay_index;
	} dig_delay;
*/

	/*
	dig_delay.upper_delay 	= 8192;
	dig_delay.lower_delay 	= 4096;
	dig_delay.speed 		= 1000; // 1000 uS
	dig_delay.delay			= 6000;
	dig_delay.delay_index 	= 0;
	*/


/*
	struct TREMOLO {
		float amplitude;
		float periodHigh;
		float periodLow;
	} tremolo;
*/
/*
	tremolo.amplitude 		= 1.0;
	tremolo.periodHigh    	= 100.0;
	tremolo.periodLow		= 50.0;
*/

/*
	struct SVF {
	   float Fupper;		// upper boundary of F
	   float Flower;        // lower boundary of F
	   float F;				// Tuning Coefficient  F1 = 2sin(pi*fc/fs)
	   float Q;				// Tuning Coefficient  Q1 = 2sigma
	   float  HPF;
	   float  BPF[2];
	   float  LPF[2];
	};
	struct SVF wah_svf;
	struct SVF bass_svf;
	struct SVF treble_svf;
*/
	wah_svf.Q[0] = 0.05; // Q = damp*2
	wah_svf.Q[1] = 0.10;
	wah_svf.Q[2] = 0.12;
	wah_svf.Q[3] = 0.15; // Q = damp*2
	wah_svf.Q[4] = 0.17;
	wah_svf.Q[5] = 0.20;
	wah_svf.Q[6] = 0.22;
	wah_svf.Q[7] = 0.24;
	wah_svf.Q[8] = 0.30;
	wah_svf.Q[9] = 0.40;


	wah_svf.F_range[0] = 0.1;
	wah_svf.F_range[0] = 0.15;
	wah_svf.F_range[0] = 0.20;
	wah_svf.F_range[0] = 0.25;
	wah_svf.F_range[0] = 0.30;
	wah_svf.F_range[0] = 0.35;
	wah_svf.F_range[0] = 0.40;
	wah_svf.F_range[0] = 0.45;
	wah_svf.F_range[0] = 0.50;

	//upper
	wah_svf.F = 0.085403;
	wah_svf.Fupper = 0.21;
	wah_svf.Flower = 0.08690;
	wah_svf.BPF[0]=0.0;
	wah_svf.BPF[1]=0.0;
	wah_svf.LPF[0]=0.0;
	wah_svf.LPF[1]=0.0;
	wah_svf.HPF=0.0;



/*
	struct PITCH_SHIFT{
		Uint16 Direction;
		float PerUpper;
		float PerLower;
		float Per;
		Uint16 count_delay1;
		Uint16 ext_index_delay1;
		int16 ext_delay;
		int16 ext_delay_prev;
		Uint16 PerReset;
	} pitch_shift;
*/

pitch_shift.Direction 		= 0; // start out pitch shifting downwards
pitch_shift.PerUpper  		= 230.0;
pitch_shift.PerLower  		= 10.0;
pitch_shift.Per				= 200.0;
pitch_shift.count_delay1	= 0;
pitch_shift.ext_index_delay1= 0;
pitch_shift.ext_delay		= 0;
pitch_shift.ext_delay_prev	= 0;
pitch_shift.PerReset		= 0;


/*
	struct SAMPLE {
		   int16 samp[5];
		   Uint16 index[5];
		   Uint16 count;
	} sample;
*/
for(k = 0; k < 5; k++)
{
sample.samp[k] 			  = 0;
sample.index[k] 		  = 0;
zcross_pos.cross_samp[k]  = 0;
zcross_pos.cross_index[k] = 0;
zcross_neg.cross_samp[k]  = 0;
zcross_neg.cross_index[k] = 0;
}

sample.count 			= 0;
zcross_pos.count_delay 	= 0;
zcross_neg.count_delay  = 0;

/*
	struct ZCROSS_POS {
	   int16   cross_samp[5];
	   Uint16  cross_index[5];
	   Uint16  count_delay;
	} zcross_pos;
*/



/*
	struct ZCROSS_NEG{
		   int16   cross_samp[5];
		   Uint16  cross_index[5];
		   Uint16  count_delay;
	} zcross_neg;
*/

}


// ****************************** //
// *** THIS IS MANO DEL FUEGO *** //
// ****************************** //
void mano_del_fuego(void)
{
/*
if(state_change_flag)
  		{
  			state_change_flag = false;
  			effectsel = Global_Board_State.FX[Global_Board_State.currentEffect].FX_index;
  			p1 = Global_Board_State.FX[Global_Board_State.currentEffect].value1;
  			p2 = Global_Board_State.FX[Global_Board_State.currentEffect].value2;
  			timer_reset = 1;
  		}
*/



  		if(d_flag == 1)
  		{
  			// Take care of IMU calculations
  			imu_dat.XgyroPrev 			= imu_dat.Xgyro;
  			imu_dat.Xgyro 				= scib_gyro;
  			imu_dat.XaccelPrev 			= imu_dat.Xaccel;
  			imu_dat.Xaccel 				= scib_rx;

  			//imu_dat.Xaccel_real_prev 	= imu_dat.Xaccel_real;
  			//imu_dat.Xaccel_real 		+= (float)(imu_dat.Xaccel - imu_dat.XaccelPrev)*0.0000305185;
  			//imu_dat.Xa_velocity    		+= imu_dat.Xaccel_real;
  			//imu_dat.Xa_pos              += imu_dat.Xa_velocity;
  			//imu_dat.Xg_pos              += (float)(imu_dat.Xgyro)*0.0000305185;

  			//FOR VIEWING IMU DATA
  			//buffer_uart[uart_i] = scib_rx;
  			//buffer_uart[uart_i] = scib_gyro;
  			//buffer_uart[uart_i] = gyro_pos;

  			// logic that handles selecting between two different effects
  			/*
  			if(scib_gyro & 0x0001)
			{
  				effectsel = (effectsel+1) & 0x0003;
			}
			*/
  			//logic that handles activating an effect
  			/*
			if((scib_rx & 0x0001) && activateEffect == 0)
			{
				activateCounter++;
				if(activateCounter > 6)
				{
					activateEffect = 1;
					activateCounter = 0;
				}
			}
			else
			{
				if(activateCounter > 0)
				{
				activateCounter--;
				}
				else{
					activateCounter = 0;
				}
			}
			if(!(scib_rx & 0x0001) && activateEffect == 1)
			{
				deactivateCounter++;
				if(deactivateCounter > 6)
				{
					activateEffect = 0;
					deactivateCounter = 0;
				}
			}
			else
			{
				if(deactivateCounter > 0)
				{
				deactivateCounter--;
				}
				else{
					deactivateCounter = 0;
				}
			}
			*/


  			if(effectsel == WAH)
  			{
  				// *** new way of doing wah, change it back if it sounds bad *** //

				if(imu_dat.Xaccel > (imu_dat.XaccelPrev+280) | imu_dat.Xaccel < (imu_dat.XaccelPrev-280)) // set threshold
				{
					//wah_svf.F += 0.0050;
					//imu_dat.Xaccel_real_prev = imu_dat.Xaccel_real;
					//imu_dat.Xaccel_real = imu_dat.Xaccel_real + (float)imu_dat.Xaccel -  (float)imu_dat.XaccelPrev;  //*0.0000305185;
					wah_svf.F += (wah_svf.Fupper)*((float)imu_dat.Xaccel -  (float)imu_dat.XaccelPrev)*0.0000305185*0.45;
					if(wah_svf.F > wah_svf.Fupper)
					{
						wah_svf.F = wah_svf.Fupper;
					}
					else if (wah_svf.F < wah_svf.Flower)
					{
						wah_svf.F = wah_svf.Flower;
					}
					//fb = 0;
				}

				dummy_buffer[dummy_index] = (float)imu_dat.Xaccel;
				dummy_index = 0x03ff & (dummy_index+1);

				// *** this is the old way of doing wah *** //
				/*
				else if (imu_dat.Xaccel < (imu_dat.XaccelPrev-280)) // set threshold
				{
					//wah_svf.F -= 0.0050;
					//imu_dat.Xaccel_real_prev = imu_dat.Xaccel_real;
					imu_dat.Xaccel_real += (float)(imu_dat.Xaccel - imu_dat.XaccelPrev)*0.0000305185;
					wah_svf.F += (wah_svf.Fupper - wah_svf.Flower)*imu_dat.Xaccel_real;
					//fb = 1;
				}
				*/
				/*
				if(timer_reset == 1)
				{
					CpuTimer1.RegsAddr->TCR.bit.TSS = 1;			// start the timer
					ConfigCpuTimer(&CpuTimer1, 150, 100);			// 150Mhz, 100uS
					CpuTimer1.RegsAddr->TCR.bit.TSS = 0;			// start the timer
					timer_reset = 0;
				}
				*/
  			}
  			else if(effectsel == FLANGER)
  			{
  				if(imu_dat.Xgyro > 500)
  				{
  					fb = 0;
  				}
  				else if (imu_dat.Xgyro < -500)
  				{
  					fb = 1;
  				}
			timer_reset = 1;
  			}

  			else if(effectsel == VOLSWELL)
  			{

  				//imu_dat.XgyroPrev 	= imu_dat.Xgyro;
  				if(activateEffect == 1)
  				{
  				gyro_vol += ((float)(imu_dat.Xgyro ))*0.0000031*0.07;
  				}
  				if(gyro_vol < 0.0)
  				{
  					gyro_vol = 0;
  				}
  				else if (gyro_vol > 1.0)
  				{
  					gyro_vol = 1.0;
  				}
  			}
  			else if(effectsel == PITCHDOWN)
  			{
  				if(imu_dat.Xgyro < 250 | imu_dat.Xgyro > 250)
				{

  					imu_dat.Xg_pos += ((float)(imu_dat.Xgyro ))*0.0000031*0.09;

  					if(imu_dat.Xg_pos < 0.0)
					{
  						imu_dat.Xg_pos = 0;
					}
					else if (imu_dat.Xg_pos > 1.0)
					{
						imu_dat.Xg_pos = 1.0;
					}

  				    pitch_shift.Per = pitch_shift.PerUpper - (pitch_shift.PerUpper - pitch_shift.PerLower)*imu_dat.Xg_pos;

  					if(pitch_shift.Per > pitch_shift.PerUpper)
  					{
  						pitch_shift.Per = pitch_shift.PerUpper;
  					}
  					if(pitch_shift.Per < pitch_shift.PerLower)
					{
						pitch_shift.Per = pitch_shift.PerLower;
					}
  					pitch_shift.PerReset = 1;
				}
  			}
  			else if(effectsel == PITCHUP)
			{
				if(imu_dat.Xgyro < 250 | imu_dat.Xgyro > 250)
				{

					imu_dat.Xg_pos += ((float)(imu_dat.Xgyro ))*0.0000031*0.09;

					if(imu_dat.Xg_pos < 0.0)
					{
						imu_dat.Xg_pos = 0;
					}
					else if (imu_dat.Xg_pos > 1.0)
					{
						imu_dat.Xg_pos = 1.0;
					}

					pitch_shift.Per = pitch_shift.PerUpper - (pitch_shift.PerUpper - pitch_shift.PerLower)*imu_dat.Xg_pos;

					if(pitch_shift.Per > pitch_shift.PerUpper)
					{
						pitch_shift.Per = pitch_shift.PerUpper;
					}
					if(pitch_shift.Per < pitch_shift.PerLower)
					{
						pitch_shift.Per = pitch_shift.PerLower;
					}
					pitch_shift.PerReset = 1;
					//pitch_shift.Per = 40;
				}
			}
  			// *** reset the d_flag to wait for next imu data packet from MCM *** //
  			d_flag = 0;
  			// *** circular buffer uart_i *** //
  	  	  	uart_i = 0x03ff & (uart_i + 1);
  	  	}

  		// Timer 1 interrupt prompts the modulation of effects
  		if(t1_flag == 1)
  		{
  			// *** Uncomment to measure timer *** //
  			//toggler = 0x0001 & ~(toggler);
  			//GpioDataRegs.GPADAT.bit.GPIO6 = toggler;


			if(effectsel == WAH)
			{
				// *** Uncomment to do old wah technique *** //
				/*
				if(fb == 0){
				wah_svf.F += 0.00004*accel_mag;
				}
				else if (fb == 1){
				wah_svf.F -= 0.00004*accel_mag;
				}
				if(wah_svf.F > 0.3113)
				{
					//fb = 1;
					wah_svf.F = 0.3113;
				}
				else if(wah_svf.F < 0.0542)
				{
					//fb = 0;
					wah_svf.F = 0.0542;
				}
				*/
			}

			else if(effectsel == FLANGER)
			{
				if(fb == 1)
				{
					flang.delay++;
					if(flang.delay > 1024 + flang.delay_range[p1])
					{
						flang.delay = 1024 + flang.delay_range[p1];
					}
				}
				else if(fb == 0)
					{
						flang.delay--;
						if(delay < 1024 - flang.delay_range[p1])
						{
							flang.delay = 1024 - flang.delay_range[p1];
						}
					}
				if(timer_reset == 1)
				{

					CpuTimer1.RegsAddr->TCR.bit.TSS = 1;					// start the timer
					ConfigCpuTimer(&CpuTimer1, 150, flang.speed[p2]);			// 150Mhz, period defined by flanger structure
					CpuTimer1.RegsAddr->TCR.bit.TSS = 0;					// start the timer
					//flang.delay = flang.lower_delay + ((flang.upper_delay - flang.lower_delay) >> 1);
					timer_reset = 0;
				}
			}
			else if(effectsel == PITCHDOWN)
			{
				pitch_shift.count_delay1 = 0x0fff  & (pitch_shift.count_delay1 + 1); // 0x0000 - 0x0fff
				if(pitch_shift.PerReset == 1)
				{
					CpuTimer1.RegsAddr->TCR.bit.TSS = 1;				// start the timer
					ConfigCpuTimer(&CpuTimer1, 150, pitch_shift.Per);	// 150Mhz, period = 100uS
					CpuTimer1.RegsAddr->TCR.bit.TSS = 0;				// start the timer
					pitch_shift.PerReset = 0;
				}
				if(timer_reset == 1)
				{

					CpuTimer1.RegsAddr->TCR.bit.TSS = 1;			// start the timer
					ConfigCpuTimer(&CpuTimer1, 150, pitch_shift.Per);			// 150Mhz, period defined by flanger structure
					CpuTimer1.RegsAddr->TCR.bit.TSS = 0;			// start the timer
					timer_reset = 0;
				}
			}
			else if(effectsel == PITCHUP)
			{

				pitch_shift.count_delay1 = 0x07ff  & (pitch_shift.count_delay1 - 1); // 0x0000 - 0x0fff
				/*
				if(pitch_shift.PerReset == 1)
				{
					CpuTimer1.RegsAddr->TCR.bit.TSS = 1;				// start the timer
					ConfigCpuTimer(&CpuTimer1, 150, pitch_shift.Per);	// 150Mhz, period = 100uS
					CpuTimer1.RegsAddr->TCR.bit.TSS = 0;				// start the timer
					pitch_shift.PerReset = 0;
				}
				if(timer_reset == 1)
				{

					CpuTimer1.RegsAddr->TCR.bit.TSS = 1;			// start the timer
					ConfigCpuTimer(&CpuTimer1, 150, pitch_shift.Per);			// 150Mhz, period defined by flanger structure
					CpuTimer1.RegsAddr->TCR.bit.TSS = 0;			// start the timer
					timer_reset = 0;
				}
				*/
			}
			t1_flag=0;
  		}

  		// Interrupt for the audio transfer
  		if(r_flag1==1)
  		{

  			// *** if effect_current == effect_sel && effectChange_flag == 1
  			// Change the corresponding effect structure in accordance with the signal chain effect parameter
  			// effectChange_flag = 0


  			// *** Audio In Audio Out with lots of interpolation *** //
  			ext_prev_inter = ext_prev;
			interpol_inc = ((*ch1_ptr - ext_prev)>>2);

			ext_prev_inter += interpol_inc;
			ext_Buffer[ext_index] = ext_prev_inter;
			sample.samp[1]  = ext_prev_inter;
			sample.index[1] = ext_index;
			ext_index = 0x7fff & (ext_index+1);

			ext_prev_inter += interpol_inc;
			ext_Buffer[ext_index] = ext_prev_inter;
			sample.samp[2] = ext_prev_inter;
			sample.index[2] = ext_index;
			ext_index = 0x7fff & (ext_index+1);

			ext_prev_inter += interpol_inc;
			ext_Buffer[ext_index] = ext_prev_inter;
			sample.samp[3] = ext_prev_inter;
			sample.index[3] = ext_index;
			ext_index = 0x7fff & (ext_index+1);

			ext_Buffer[ext_index] = *ch1_ptr;
			sample.samp[4] = *ch1_ptr;
			sample.index[4] = ext_index;

			// *** delay samples for pitch shifitng upward *** //
			sample_delay.samp[0] = sample_delay.samp[4];
			sample_delay.index[0] = sample_delay.index[4];
			sample_delay.index[4] = 0x7fff & (ext_index - 0x03ff);
			sample_delay.samp[4] = ext_Buffer[sample_delay.index[4]];
		    sample_delay.index[3] = 0x7fff & (ext_index - 0x03ff-1);
		    sample_delay.samp[3] = ext_Buffer[sample_delay.index[3]];
		    sample_delay.index[2] = 0x7fff & (ext_index - 0x03ff-2);
		    sample_delay.samp[2] = ext_Buffer[sample_delay.index[2]];
			sample_delay.index[1] = 0x7fff & (ext_index - 0x03ff-3);
		    sample_delay.samp[1] = ext_Buffer[sample_delay.index[1]];


  			// *** State Variable Filter output *** //
  			// *** Used for the 'wah' effect *** //
  			if(effectsel == WAH)
			{
				wah_svf.HPF    = ((float)(*ch1_ptr))*0.000031 - wah_svf.LPF[0] - (wah_svf.Q[p1])*(wah_svf.BPF[0]); // index Q using Nick's structure
				wah_svf.BPF[1] = (wah_svf.F)*(wah_svf.HPF) + wah_svf.BPF[0];
				wah_svf.LPF[1] = (wah_svf.F)*(wah_svf.BPF[1]) + wah_svf.LPF[0];

				// *** Current values become past values *** //
				wah_svf.BPF[0] = wah_svf.BPF[1];
				wah_svf.LPF[0] = wah_svf.LPF[1];


				 McbspaRegs.DXR2.all = (int16)((wah_svf.BPF[1])*32767.0);
				 McbspaRegs.DXR1.all = McbspaRegs.DXR2.all;

				 // *** dummy buffer *** //
				 //dummy_buffer[dummy_index] = wah_svf.F;
				 //dummy_index = 0x03ff & (dummy_index + 1);
			}
  			else if (effectsel == FLANGER)
  			{
  				// *** Flanger Effect *** //
  				flang.delay_index = 0x7fff & (ext_index - flang.delay);
				McbspaRegs.DXR2.all = (ext_Buffer[flang.delay_index] >> 1) + (ext_Buffer[ext_index] >> 1);
				McbspaRegs.DXR1.all = McbspaRegs.DXR2.all;
  			}
  			else if (effectsel == VOLSWELL)
  			{
  				float fIn = (float)(*ch1_ptr)*0.000031*gyro_vol;
  				McbspaRegs.DXR2.all = (int16)(fIn*32767.0);
  				McbspaRegs.DXR1.all = (int16)(fIn*32767.0);

  				// *** dummy buffer *** //
  				//dummy_buffer[dummy_index] = gyro_vol;
  				//dummy_index = 0x03ff & (dummy_index + 1);
  			}
  			else if (effectsel == BYPASS)
  			{
  				// *** View the IMU Data real time from the DAC *** //
  				//McbspaRegs.DXR2.all = imu_dat.Xaccel;
  				//McbspaRegs.DXR2.all = imu_dat.Xgyro;
  				//McbspaRegs.DXR1.all = McbspaRegs.DXR2.all;
  				McbspaRegs.DXR2.all = *ch1_ptr;
  				McbspaRegs.DXR1.all = *ch1_ptr;
			}


  			// *******************************************************************************************************
  			// 							Pitch Shifting variables
  			// *******************************************************************************************************
  			else if (effectsel == PITCHDOWN)
  			{

  				pitch_shift.ext_index_delay1 = 0x7fff & (ext_index - pitch_shift.count_delay1);
  				zcross_pos.count_delay = 0x07ff & (zcross_pos.count_delay + 4);
  				zcross_neg.count_delay = 0x07ff & (zcross_neg.count_delay + 4);

  				if(*ch1_ptr > 0 & ext_prev < 0)
  				{
  					//zcross_pos_d = ext_index;
  					//count_delay_pos = 0;
  					zcross_pos.cross_samp[0] = sample.samp[0];
  					zcross_pos.cross_samp[1] = sample.samp[1];
  					zcross_pos.cross_samp[2] = sample.samp[2];
  					zcross_pos.cross_samp[3] = sample.samp[3];
  					zcross_pos.cross_samp[4] = sample.samp[4];
  					zcross_pos.cross_index[0] = sample.index[0];
  					zcross_pos.cross_index[1] = sample.index[1];
  					zcross_pos.cross_index[2] = sample.index[2];
  					zcross_pos.cross_index[3] = sample.index[3];
  					zcross_pos.cross_index[4] = sample.index[4];
  					zcross_pos.count_delay = 0;
  					//count_delay_pos_real = 0;
  				}
  				else if(*ch1_ptr < 0 & ext_prev > 0)
  				{
  					//zcross_neg_d = ext_index;
  					//count_delay_neg = 0;
  					zcross_neg.cross_samp[0] = sample.samp[0];
					zcross_neg.cross_samp[1] = sample.samp[1];
					zcross_neg.cross_samp[2] = sample.samp[2];
					zcross_neg.cross_samp[3] = sample.samp[3];
					zcross_neg.cross_samp[4] = sample.samp[4];
					zcross_neg.cross_index[0] = sample.index[0];
					zcross_neg.cross_index[1] = sample.index[1];
					zcross_neg.cross_index[2] = sample.index[2];
					zcross_neg.cross_index[3] = sample.index[3];
					zcross_neg.cross_index[4] = sample.index[4];
					zcross_neg.count_delay = 0;
  					//count_delay_neg_real = 0;
  				}
  				if(pitch_shift.count_delay1 > 2048)
  				{
  					// *** positive zero crossing occurred! *** //
  					// *** check if update is appropriate   *** //
  					if(ext_Buffer[pitch_shift.ext_index_delay1] > 0 & pitch_shift.ext_delay_prev < 0)
  					{
  						closest_d = 0x7fff;
  						for(k = 1; k < 4; k++)
  						{
  							temp_d = zcross_pos.cross_samp[k] - ext_Buffer[pitch_shift.ext_index_delay1];
  							if(temp_d  > 0)
  							{
  								if(temp_d < closest_d)
  								{
  									closest_d = temp_d;
  									temp_index = zcross_pos.cross_index[k];
  									temp_count_offset = k - 1;
  								}
  							}
  						}
  						if(closest_d < 128)
  						{
  							pitch_shift.count_delay1 = 0;
  							pitch_shift.ext_index_delay1 = temp_index;
  							if(zcross_pos.count_delay > 0)
							{
								pitch_shift.count_delay1 = zcross_pos.count_delay - temp_count_offset;
							}
  							GpioDataRegs.GPATOGGLE.bit.GPIO12	= 1;       //testing to find the pitch shifting artifact
  						}
  						//count_delay1 = count_delay_pos;
  						//ext_index_delay1 = zcross_pos_d;
  					}

  					else if(ext_Buffer[pitch_shift.ext_index_delay1] < 0 & pitch_shift.ext_delay_prev > 0)
  					{
  						// negative zero crossing occurred!
  						// check if update is appropriate
  						closest_d = 0x8000;
  						for(k = 1; k < 4; k++)
						{
							temp_d = zcross_neg.cross_samp[k] - ext_Buffer[pitch_shift.ext_index_delay1];
							if(temp_d  < 0)
							{
								if(temp_d > closest_d)
								{
									closest_d = temp_d;
									temp_index = zcross_neg.cross_index[k];
									temp_count_offset = k - 1;
								}
							}
						}
						if(closest_d > -128)
						{
							pitch_shift.count_delay1 = 0;
							pitch_shift.ext_index_delay1 = temp_index;
							if(zcross_neg.count_delay > 0)
							{
								pitch_shift.count_delay1 = zcross_neg.count_delay - temp_count_offset;
							}
							//GpioDataRegs.GPATOGGLE.bit.GPIO12	= 1;        //testing to find the pitch shifting artifact
							zcrosstrig = 1;
						}
  						//count_delay1 = count_delay_neg;
  						//ext_index_delay1 = zcross_neg_d;
  					}
  				}

  				// *** for debugging purposes only, set breakpoint inside *** //
  				if(pitch_shift.count_delay1 > 4000)
  				{
  					pitch_shift.count_delay1 = 0;
  				}

  				if (imu_dat.Xg_pos <= 0.01 & imu_dat.Xg_pos >= 0.0)
  				{
  					McbspaRegs.DXR2.all = *ch1_ptr;
  					McbspaRegs.DXR1.all = McbspaRegs.DXR2.all;
  					if(zcrosstrig)
  					{
  					GpioDataRegs.GPATOGGLE.bit.GPIO12 = 1;
  					}
  					zcrosstrig = 0;

  				}
  				else
  				{
  					McbspaRegs.DXR2.all = (ext_Buffer[pitch_shift.ext_index_delay1]);
  					McbspaRegs.DXR1.all = McbspaRegs.DXR2.all;
  				}
  				pitch_shift.ext_delay_prev = ext_Buffer[pitch_shift.ext_index_delay1];

  			}

  			else if (effectsel == PITCHUP)
			{

				pitch_shift.ext_index_delay1 = 0x7fff & (ext_index - pitch_shift.count_delay1);
				zcross_pos.count_delay = 0x07ff & (zcross_pos.count_delay + 4);
				zcross_neg.count_delay = 0x07ff & (zcross_neg.count_delay + 4);

				if(sample_delay.samp[4] > 0 & sample_delay.samp[0] < 0)
				{
					zcross_pos.cross_samp[0] = sample_delay.samp[0];
					zcross_pos.cross_samp[1] = sample_delay.samp[1];
					zcross_pos.cross_samp[2] = sample_delay.samp[2];
					zcross_pos.cross_samp[3] = sample_delay.samp[3];
					zcross_pos.cross_samp[4] = sample_delay.samp[4];
					zcross_pos.cross_index[0] = sample_delay.index[0];
					zcross_pos.cross_index[1] = sample_delay.index[1];
					zcross_pos.cross_index[2] = sample_delay.index[2];
					zcross_pos.cross_index[3] = sample_delay.index[3];
					zcross_pos.cross_index[4] = sample_delay.index[4];
					zcross_pos.count_delay = 0x3ff;
				}
				else if(sample_delay.samp[4] < 0 & sample_delay.samp[0] > 0)
				{
					//zcross_neg_d = ext_index;
					//count_delay_neg = 0;
					zcross_neg.cross_samp[0] = sample_delay.samp[0];
					zcross_neg.cross_samp[1] = sample_delay.samp[1];
					zcross_neg.cross_samp[2] = sample_delay.samp[2];
					zcross_neg.cross_samp[3] = sample_delay.samp[3];
					zcross_neg.cross_samp[4] = sample_delay.samp[4];
					zcross_neg.cross_index[0] = sample_delay.index[0];
					zcross_neg.cross_index[1] = sample_delay.index[1];
					zcross_neg.cross_index[2] = sample_delay.index[2];
					zcross_neg.cross_index[3] = sample_delay.index[3];
					zcross_neg.cross_index[4] = sample_delay.index[4];
					zcross_neg.count_delay = 0x3ff;
					//count_delay_neg_real = 0;
				}
				if(pitch_shift.count_delay1 < 512)
				{
					// *** positive zero crossing occurred! *** //
					// *** check if update is appropriate   *** //
					if(ext_Buffer[pitch_shift.ext_index_delay1] > 0 & pitch_shift.ext_delay_prev < 0)
					{
						closest_d = 0x7fff;
						for(k = 1; k < 4; k++)
						{
							temp_d = zcross_pos.cross_samp[k] - ext_Buffer[pitch_shift.ext_index_delay1];
							if(temp_d  > 0)
							{
								if(temp_d < closest_d)
								{
									closest_d = temp_d;
									temp_index = zcross_pos.cross_index[k];
									temp_count_offset = k - 1;
								}
							}
						}
						if(closest_d < 128)
						{
							pitch_shift.count_delay1 = zcross_neg.count_delay;
							pitch_shift.ext_index_delay1 = temp_index;
							if(zcross_pos.count_delay > 0)
							{
								pitch_shift.count_delay1 = zcross_pos.count_delay + temp_count_offset;
							}
							prevcountstart = pitch_shift.count_delay1;
							//GpioDataRegs.GPATOGGLE.bit.GPIO12	= 1;
						}

						//count_delay1 = count_delay_pos;
						//ext_index_delay1 = zcross_pos_d;
					}

					else if(ext_Buffer[pitch_shift.ext_index_delay1] < 0 & pitch_shift.ext_delay_prev > 0)
					{
						//GpioDataRegs.GPATOGGLE.bit.GPIO12	= 1;
						// negative zero crossing occurred!
						// check if update is appropriate
						closest_d = 0x8000;
						for(k = 1; k < 4; k++)
						{
							temp_d = zcross_neg.cross_samp[k] - ext_Buffer[pitch_shift.ext_index_delay1];
							if(temp_d  < 0)
							{
								if(temp_d > closest_d)
								{
									closest_d = temp_d;
									temp_index = zcross_neg.cross_index[k];
									temp_count_offset = k - 1;
								}
							}
						}
						if(closest_d > -128)
						{
							pitch_shift.count_delay1 = zcross_neg.count_delay;
							pitch_shift.ext_index_delay1 = temp_index;
							if(zcross_neg.count_delay > 0)
							{
								pitch_shift.count_delay1 = zcross_neg.count_delay + temp_count_offset;
							}
							prevcountstart = pitch_shift.count_delay1;
							//GpioDataRegs.GPATOGGLE.bit.GPIO12	= 1;
						}
						//count_delay1 = count_delay_neg;
						//ext_index_delay1 = zcross_neg_d;
					}
				}

				// *** for debugging purposes only, set breakpoint inside *** //
				if(pitch_shift.count_delay1 < 8)
				{
					pitch_shift.count_delay1 = 0x3ff;
					//GpioDataRegs.GPATOGGLE.bit.GPIO12	= 1;
					zcrosstrig = 1;
				}

				//if (imu_dat.Xg_pos <= 0.03 & imu_dat.Xg_pos >= 0.0)
				//{
					//McbspaRegs.DXR2.all = *ch1_ptr;
					//McbspaRegs.DXR1.all = McbspaRegs.DXR2.all;
				//}
				//else
				//{
					McbspaRegs.DXR2.all = (ext_Buffer[pitch_shift.ext_index_delay1]);
					McbspaRegs.DXR1.all = McbspaRegs.DXR2.all;
					if(zcrosstrig)
					{
						GpioDataRegs.GPATOGGLE.bit.GPIO12 = 1;
					}
					zcrosstrig = 0;
				//}
				pitch_shift.ext_delay_prev = ext_Buffer[pitch_shift.ext_index_delay1];

			}


  			// *** finish audio buffer *** //
  			ext_prev = ext_Buffer[ext_index];
			sample.samp[0] = ext_prev;
			sample.index[0] = ext_index;
			ext_index = 0x7fff & (ext_index+1);

			// *** reset flag for sampler *** //
  			r_flag1=0;
  		}


  	}






//===========================================================================
// End of file.
//===========================================================================

